// Code generated by entc, DO NOT EDIT.

package market

import (
	"compound/internal/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// UpdateTime applies equality check predicate on the "update_time" field. It's identical to UpdateTimeEQ.
func UpdateTime(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// Address applies equality check predicate on the "address" field. It's identical to AddressEQ.
func Address(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAddress), v))
	})
}

// Symbol applies equality check predicate on the "symbol" field. It's identical to SymbolEQ.
func Symbol(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSymbol), v))
	})
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// BorrowIndex applies equality check predicate on the "borrow_index" field. It's identical to BorrowIndexEQ.
func BorrowIndex(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBorrowIndex), v))
	})
}

// BorrowRate applies equality check predicate on the "borrow_rate" field. It's identical to BorrowRateEQ.
func BorrowRate(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBorrowRate), v))
	})
}

// SupplyRate applies equality check predicate on the "supply_rate" field. It's identical to SupplyRateEQ.
func SupplyRate(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSupplyRate), v))
	})
}

// Cash applies equality check predicate on the "cash" field. It's identical to CashEQ.
func Cash(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCash), v))
	})
}

// CollateralFactor applies equality check predicate on the "collateral_factor" field. It's identical to CollateralFactorEQ.
func CollateralFactor(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCollateralFactor), v))
	})
}

// ExchangeRate applies equality check predicate on the "exchange_rate" field. It's identical to ExchangeRateEQ.
func ExchangeRate(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExchangeRate), v))
	})
}

// ReserveFactor applies equality check predicate on the "reserve_factor" field. It's identical to ReserveFactorEQ.
func ReserveFactor(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReserveFactor), v))
	})
}

// Reserves applies equality check predicate on the "reserves" field. It's identical to ReservesEQ.
func Reserves(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReserves), v))
	})
}

// TotalBorrows applies equality check predicate on the "total_borrows" field. It's identical to TotalBorrowsEQ.
func TotalBorrows(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalBorrows), v))
	})
}

// TotalSupply applies equality check predicate on the "total_supply" field. It's identical to TotalSupplyEQ.
func TotalSupply(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalSupply), v))
	})
}

// UnderlyingAddress applies equality check predicate on the "underlying_address" field. It's identical to UnderlyingAddressEQ.
func UnderlyingAddress(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingName applies equality check predicate on the "underlying_name" field. It's identical to UnderlyingNameEQ.
func UnderlyingName(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingSymbol applies equality check predicate on the "underlying_symbol" field. It's identical to UnderlyingSymbolEQ.
func UnderlyingSymbol(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingPrice applies equality check predicate on the "underlying_price" field. It's identical to UnderlyingPriceEQ.
func UnderlyingPrice(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingDecimals applies equality check predicate on the "underlying_decimals" field. It's identical to UnderlyingDecimalsEQ.
func UnderlyingDecimals(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingDecimals), v))
	})
}

// UnderlyingPriceUsd applies equality check predicate on the "underlying_price_usd" field. It's identical to UnderlyingPriceUsdEQ.
func UnderlyingPriceUsd(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// BlockNumber applies equality check predicate on the "block_number" field. It's identical to BlockNumberEQ.
func BlockNumber(v uint64) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBlockNumber), v))
	})
}

// BlockTimestamp applies equality check predicate on the "block_timestamp" field. It's identical to BlockTimestampEQ.
func BlockTimestamp(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBlockTimestamp), v))
	})
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...time.Time) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...time.Time) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateTime), v))
	})
}

// UpdateTimeEQ applies the EQ predicate on the "update_time" field.
func UpdateTimeEQ(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeNEQ applies the NEQ predicate on the "update_time" field.
func UpdateTimeNEQ(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeIn applies the In predicate on the "update_time" field.
func UpdateTimeIn(vs ...time.Time) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeNotIn applies the NotIn predicate on the "update_time" field.
func UpdateTimeNotIn(vs ...time.Time) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeGT applies the GT predicate on the "update_time" field.
func UpdateTimeGT(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeGTE applies the GTE predicate on the "update_time" field.
func UpdateTimeGTE(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLT applies the LT predicate on the "update_time" field.
func UpdateTimeLT(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLTE applies the LTE predicate on the "update_time" field.
func UpdateTimeLTE(v time.Time) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateTime), v))
	})
}

// AddressEQ applies the EQ predicate on the "address" field.
func AddressEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAddress), v))
	})
}

// AddressNEQ applies the NEQ predicate on the "address" field.
func AddressNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAddress), v))
	})
}

// AddressIn applies the In predicate on the "address" field.
func AddressIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAddress), v...))
	})
}

// AddressNotIn applies the NotIn predicate on the "address" field.
func AddressNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAddress), v...))
	})
}

// AddressGT applies the GT predicate on the "address" field.
func AddressGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAddress), v))
	})
}

// AddressGTE applies the GTE predicate on the "address" field.
func AddressGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAddress), v))
	})
}

// AddressLT applies the LT predicate on the "address" field.
func AddressLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAddress), v))
	})
}

// AddressLTE applies the LTE predicate on the "address" field.
func AddressLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAddress), v))
	})
}

// AddressContains applies the Contains predicate on the "address" field.
func AddressContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAddress), v))
	})
}

// AddressHasPrefix applies the HasPrefix predicate on the "address" field.
func AddressHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAddress), v))
	})
}

// AddressHasSuffix applies the HasSuffix predicate on the "address" field.
func AddressHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAddress), v))
	})
}

// AddressEqualFold applies the EqualFold predicate on the "address" field.
func AddressEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAddress), v))
	})
}

// AddressContainsFold applies the ContainsFold predicate on the "address" field.
func AddressContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAddress), v))
	})
}

// SymbolEQ applies the EQ predicate on the "symbol" field.
func SymbolEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSymbol), v))
	})
}

// SymbolNEQ applies the NEQ predicate on the "symbol" field.
func SymbolNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSymbol), v))
	})
}

// SymbolIn applies the In predicate on the "symbol" field.
func SymbolIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSymbol), v...))
	})
}

// SymbolNotIn applies the NotIn predicate on the "symbol" field.
func SymbolNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSymbol), v...))
	})
}

// SymbolGT applies the GT predicate on the "symbol" field.
func SymbolGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSymbol), v))
	})
}

// SymbolGTE applies the GTE predicate on the "symbol" field.
func SymbolGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSymbol), v))
	})
}

// SymbolLT applies the LT predicate on the "symbol" field.
func SymbolLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSymbol), v))
	})
}

// SymbolLTE applies the LTE predicate on the "symbol" field.
func SymbolLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSymbol), v))
	})
}

// SymbolContains applies the Contains predicate on the "symbol" field.
func SymbolContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSymbol), v))
	})
}

// SymbolHasPrefix applies the HasPrefix predicate on the "symbol" field.
func SymbolHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSymbol), v))
	})
}

// SymbolHasSuffix applies the HasSuffix predicate on the "symbol" field.
func SymbolHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSymbol), v))
	})
}

// SymbolEqualFold applies the EqualFold predicate on the "symbol" field.
func SymbolEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSymbol), v))
	})
}

// SymbolContainsFold applies the ContainsFold predicate on the "symbol" field.
func SymbolContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSymbol), v))
	})
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldName), v))
	})
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldName), v...))
	})
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldName), v...))
	})
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldName), v))
	})
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldName), v))
	})
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldName), v))
	})
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldName), v))
	})
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldName), v))
	})
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldName), v))
	})
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldName), v))
	})
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldName), v))
	})
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldName), v))
	})
}

// BorrowIndexEQ applies the EQ predicate on the "borrow_index" field.
func BorrowIndexEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexNEQ applies the NEQ predicate on the "borrow_index" field.
func BorrowIndexNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexIn applies the In predicate on the "borrow_index" field.
func BorrowIndexIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBorrowIndex), v...))
	})
}

// BorrowIndexNotIn applies the NotIn predicate on the "borrow_index" field.
func BorrowIndexNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBorrowIndex), v...))
	})
}

// BorrowIndexGT applies the GT predicate on the "borrow_index" field.
func BorrowIndexGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexGTE applies the GTE predicate on the "borrow_index" field.
func BorrowIndexGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexLT applies the LT predicate on the "borrow_index" field.
func BorrowIndexLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexLTE applies the LTE predicate on the "borrow_index" field.
func BorrowIndexLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexContains applies the Contains predicate on the "borrow_index" field.
func BorrowIndexContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexHasPrefix applies the HasPrefix predicate on the "borrow_index" field.
func BorrowIndexHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexHasSuffix applies the HasSuffix predicate on the "borrow_index" field.
func BorrowIndexHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexEqualFold applies the EqualFold predicate on the "borrow_index" field.
func BorrowIndexEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBorrowIndex), v))
	})
}

// BorrowIndexContainsFold applies the ContainsFold predicate on the "borrow_index" field.
func BorrowIndexContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBorrowIndex), v))
	})
}

// BorrowRateEQ applies the EQ predicate on the "borrow_rate" field.
func BorrowRateEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateNEQ applies the NEQ predicate on the "borrow_rate" field.
func BorrowRateNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateIn applies the In predicate on the "borrow_rate" field.
func BorrowRateIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBorrowRate), v...))
	})
}

// BorrowRateNotIn applies the NotIn predicate on the "borrow_rate" field.
func BorrowRateNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBorrowRate), v...))
	})
}

// BorrowRateGT applies the GT predicate on the "borrow_rate" field.
func BorrowRateGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateGTE applies the GTE predicate on the "borrow_rate" field.
func BorrowRateGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateLT applies the LT predicate on the "borrow_rate" field.
func BorrowRateLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateLTE applies the LTE predicate on the "borrow_rate" field.
func BorrowRateLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateContains applies the Contains predicate on the "borrow_rate" field.
func BorrowRateContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateHasPrefix applies the HasPrefix predicate on the "borrow_rate" field.
func BorrowRateHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateHasSuffix applies the HasSuffix predicate on the "borrow_rate" field.
func BorrowRateHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateEqualFold applies the EqualFold predicate on the "borrow_rate" field.
func BorrowRateEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBorrowRate), v))
	})
}

// BorrowRateContainsFold applies the ContainsFold predicate on the "borrow_rate" field.
func BorrowRateContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBorrowRate), v))
	})
}

// SupplyRateEQ applies the EQ predicate on the "supply_rate" field.
func SupplyRateEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateNEQ applies the NEQ predicate on the "supply_rate" field.
func SupplyRateNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateIn applies the In predicate on the "supply_rate" field.
func SupplyRateIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSupplyRate), v...))
	})
}

// SupplyRateNotIn applies the NotIn predicate on the "supply_rate" field.
func SupplyRateNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSupplyRate), v...))
	})
}

// SupplyRateGT applies the GT predicate on the "supply_rate" field.
func SupplyRateGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateGTE applies the GTE predicate on the "supply_rate" field.
func SupplyRateGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateLT applies the LT predicate on the "supply_rate" field.
func SupplyRateLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateLTE applies the LTE predicate on the "supply_rate" field.
func SupplyRateLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateContains applies the Contains predicate on the "supply_rate" field.
func SupplyRateContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateHasPrefix applies the HasPrefix predicate on the "supply_rate" field.
func SupplyRateHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateHasSuffix applies the HasSuffix predicate on the "supply_rate" field.
func SupplyRateHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateEqualFold applies the EqualFold predicate on the "supply_rate" field.
func SupplyRateEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSupplyRate), v))
	})
}

// SupplyRateContainsFold applies the ContainsFold predicate on the "supply_rate" field.
func SupplyRateContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSupplyRate), v))
	})
}

// CashEQ applies the EQ predicate on the "cash" field.
func CashEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCash), v))
	})
}

// CashNEQ applies the NEQ predicate on the "cash" field.
func CashNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCash), v))
	})
}

// CashIn applies the In predicate on the "cash" field.
func CashIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCash), v...))
	})
}

// CashNotIn applies the NotIn predicate on the "cash" field.
func CashNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCash), v...))
	})
}

// CashGT applies the GT predicate on the "cash" field.
func CashGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCash), v))
	})
}

// CashGTE applies the GTE predicate on the "cash" field.
func CashGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCash), v))
	})
}

// CashLT applies the LT predicate on the "cash" field.
func CashLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCash), v))
	})
}

// CashLTE applies the LTE predicate on the "cash" field.
func CashLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCash), v))
	})
}

// CashContains applies the Contains predicate on the "cash" field.
func CashContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCash), v))
	})
}

// CashHasPrefix applies the HasPrefix predicate on the "cash" field.
func CashHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCash), v))
	})
}

// CashHasSuffix applies the HasSuffix predicate on the "cash" field.
func CashHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCash), v))
	})
}

// CashEqualFold applies the EqualFold predicate on the "cash" field.
func CashEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCash), v))
	})
}

// CashContainsFold applies the ContainsFold predicate on the "cash" field.
func CashContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCash), v))
	})
}

// CollateralFactorEQ applies the EQ predicate on the "collateral_factor" field.
func CollateralFactorEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorNEQ applies the NEQ predicate on the "collateral_factor" field.
func CollateralFactorNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorIn applies the In predicate on the "collateral_factor" field.
func CollateralFactorIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCollateralFactor), v...))
	})
}

// CollateralFactorNotIn applies the NotIn predicate on the "collateral_factor" field.
func CollateralFactorNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCollateralFactor), v...))
	})
}

// CollateralFactorGT applies the GT predicate on the "collateral_factor" field.
func CollateralFactorGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorGTE applies the GTE predicate on the "collateral_factor" field.
func CollateralFactorGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorLT applies the LT predicate on the "collateral_factor" field.
func CollateralFactorLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorLTE applies the LTE predicate on the "collateral_factor" field.
func CollateralFactorLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorContains applies the Contains predicate on the "collateral_factor" field.
func CollateralFactorContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorHasPrefix applies the HasPrefix predicate on the "collateral_factor" field.
func CollateralFactorHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorHasSuffix applies the HasSuffix predicate on the "collateral_factor" field.
func CollateralFactorHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorEqualFold applies the EqualFold predicate on the "collateral_factor" field.
func CollateralFactorEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCollateralFactor), v))
	})
}

// CollateralFactorContainsFold applies the ContainsFold predicate on the "collateral_factor" field.
func CollateralFactorContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCollateralFactor), v))
	})
}

// ExchangeRateEQ applies the EQ predicate on the "exchange_rate" field.
func ExchangeRateEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateNEQ applies the NEQ predicate on the "exchange_rate" field.
func ExchangeRateNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateIn applies the In predicate on the "exchange_rate" field.
func ExchangeRateIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExchangeRate), v...))
	})
}

// ExchangeRateNotIn applies the NotIn predicate on the "exchange_rate" field.
func ExchangeRateNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExchangeRate), v...))
	})
}

// ExchangeRateGT applies the GT predicate on the "exchange_rate" field.
func ExchangeRateGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateGTE applies the GTE predicate on the "exchange_rate" field.
func ExchangeRateGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateLT applies the LT predicate on the "exchange_rate" field.
func ExchangeRateLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateLTE applies the LTE predicate on the "exchange_rate" field.
func ExchangeRateLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateContains applies the Contains predicate on the "exchange_rate" field.
func ExchangeRateContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateHasPrefix applies the HasPrefix predicate on the "exchange_rate" field.
func ExchangeRateHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateHasSuffix applies the HasSuffix predicate on the "exchange_rate" field.
func ExchangeRateHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateEqualFold applies the EqualFold predicate on the "exchange_rate" field.
func ExchangeRateEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateContainsFold applies the ContainsFold predicate on the "exchange_rate" field.
func ExchangeRateContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldExchangeRate), v))
	})
}

// ReserveFactorEQ applies the EQ predicate on the "reserve_factor" field.
func ReserveFactorEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorNEQ applies the NEQ predicate on the "reserve_factor" field.
func ReserveFactorNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorIn applies the In predicate on the "reserve_factor" field.
func ReserveFactorIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldReserveFactor), v...))
	})
}

// ReserveFactorNotIn applies the NotIn predicate on the "reserve_factor" field.
func ReserveFactorNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldReserveFactor), v...))
	})
}

// ReserveFactorGT applies the GT predicate on the "reserve_factor" field.
func ReserveFactorGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorGTE applies the GTE predicate on the "reserve_factor" field.
func ReserveFactorGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorLT applies the LT predicate on the "reserve_factor" field.
func ReserveFactorLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorLTE applies the LTE predicate on the "reserve_factor" field.
func ReserveFactorLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorContains applies the Contains predicate on the "reserve_factor" field.
func ReserveFactorContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorHasPrefix applies the HasPrefix predicate on the "reserve_factor" field.
func ReserveFactorHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorHasSuffix applies the HasSuffix predicate on the "reserve_factor" field.
func ReserveFactorHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorEqualFold applies the EqualFold predicate on the "reserve_factor" field.
func ReserveFactorEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldReserveFactor), v))
	})
}

// ReserveFactorContainsFold applies the ContainsFold predicate on the "reserve_factor" field.
func ReserveFactorContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldReserveFactor), v))
	})
}

// ReservesEQ applies the EQ predicate on the "reserves" field.
func ReservesEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReserves), v))
	})
}

// ReservesNEQ applies the NEQ predicate on the "reserves" field.
func ReservesNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReserves), v))
	})
}

// ReservesIn applies the In predicate on the "reserves" field.
func ReservesIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldReserves), v...))
	})
}

// ReservesNotIn applies the NotIn predicate on the "reserves" field.
func ReservesNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldReserves), v...))
	})
}

// ReservesGT applies the GT predicate on the "reserves" field.
func ReservesGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldReserves), v))
	})
}

// ReservesGTE applies the GTE predicate on the "reserves" field.
func ReservesGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldReserves), v))
	})
}

// ReservesLT applies the LT predicate on the "reserves" field.
func ReservesLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldReserves), v))
	})
}

// ReservesLTE applies the LTE predicate on the "reserves" field.
func ReservesLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldReserves), v))
	})
}

// ReservesContains applies the Contains predicate on the "reserves" field.
func ReservesContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldReserves), v))
	})
}

// ReservesHasPrefix applies the HasPrefix predicate on the "reserves" field.
func ReservesHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldReserves), v))
	})
}

// ReservesHasSuffix applies the HasSuffix predicate on the "reserves" field.
func ReservesHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldReserves), v))
	})
}

// ReservesEqualFold applies the EqualFold predicate on the "reserves" field.
func ReservesEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldReserves), v))
	})
}

// ReservesContainsFold applies the ContainsFold predicate on the "reserves" field.
func ReservesContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldReserves), v))
	})
}

// TotalBorrowsEQ applies the EQ predicate on the "total_borrows" field.
func TotalBorrowsEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsNEQ applies the NEQ predicate on the "total_borrows" field.
func TotalBorrowsNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsIn applies the In predicate on the "total_borrows" field.
func TotalBorrowsIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTotalBorrows), v...))
	})
}

// TotalBorrowsNotIn applies the NotIn predicate on the "total_borrows" field.
func TotalBorrowsNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTotalBorrows), v...))
	})
}

// TotalBorrowsGT applies the GT predicate on the "total_borrows" field.
func TotalBorrowsGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsGTE applies the GTE predicate on the "total_borrows" field.
func TotalBorrowsGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsLT applies the LT predicate on the "total_borrows" field.
func TotalBorrowsLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsLTE applies the LTE predicate on the "total_borrows" field.
func TotalBorrowsLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsContains applies the Contains predicate on the "total_borrows" field.
func TotalBorrowsContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsHasPrefix applies the HasPrefix predicate on the "total_borrows" field.
func TotalBorrowsHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsHasSuffix applies the HasSuffix predicate on the "total_borrows" field.
func TotalBorrowsHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsEqualFold applies the EqualFold predicate on the "total_borrows" field.
func TotalBorrowsEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTotalBorrows), v))
	})
}

// TotalBorrowsContainsFold applies the ContainsFold predicate on the "total_borrows" field.
func TotalBorrowsContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTotalBorrows), v))
	})
}

// TotalSupplyEQ applies the EQ predicate on the "total_supply" field.
func TotalSupplyEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyNEQ applies the NEQ predicate on the "total_supply" field.
func TotalSupplyNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyIn applies the In predicate on the "total_supply" field.
func TotalSupplyIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTotalSupply), v...))
	})
}

// TotalSupplyNotIn applies the NotIn predicate on the "total_supply" field.
func TotalSupplyNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTotalSupply), v...))
	})
}

// TotalSupplyGT applies the GT predicate on the "total_supply" field.
func TotalSupplyGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyGTE applies the GTE predicate on the "total_supply" field.
func TotalSupplyGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyLT applies the LT predicate on the "total_supply" field.
func TotalSupplyLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyLTE applies the LTE predicate on the "total_supply" field.
func TotalSupplyLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyContains applies the Contains predicate on the "total_supply" field.
func TotalSupplyContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyHasPrefix applies the HasPrefix predicate on the "total_supply" field.
func TotalSupplyHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyHasSuffix applies the HasSuffix predicate on the "total_supply" field.
func TotalSupplyHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyEqualFold applies the EqualFold predicate on the "total_supply" field.
func TotalSupplyEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTotalSupply), v))
	})
}

// TotalSupplyContainsFold applies the ContainsFold predicate on the "total_supply" field.
func TotalSupplyContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTotalSupply), v))
	})
}

// UnderlyingAddressEQ applies the EQ predicate on the "underlying_address" field.
func UnderlyingAddressEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressNEQ applies the NEQ predicate on the "underlying_address" field.
func UnderlyingAddressNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressIn applies the In predicate on the "underlying_address" field.
func UnderlyingAddressIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUnderlyingAddress), v...))
	})
}

// UnderlyingAddressNotIn applies the NotIn predicate on the "underlying_address" field.
func UnderlyingAddressNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUnderlyingAddress), v...))
	})
}

// UnderlyingAddressGT applies the GT predicate on the "underlying_address" field.
func UnderlyingAddressGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressGTE applies the GTE predicate on the "underlying_address" field.
func UnderlyingAddressGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressLT applies the LT predicate on the "underlying_address" field.
func UnderlyingAddressLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressLTE applies the LTE predicate on the "underlying_address" field.
func UnderlyingAddressLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressContains applies the Contains predicate on the "underlying_address" field.
func UnderlyingAddressContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressHasPrefix applies the HasPrefix predicate on the "underlying_address" field.
func UnderlyingAddressHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressHasSuffix applies the HasSuffix predicate on the "underlying_address" field.
func UnderlyingAddressHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressEqualFold applies the EqualFold predicate on the "underlying_address" field.
func UnderlyingAddressEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingAddressContainsFold applies the ContainsFold predicate on the "underlying_address" field.
func UnderlyingAddressContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUnderlyingAddress), v))
	})
}

// UnderlyingNameEQ applies the EQ predicate on the "underlying_name" field.
func UnderlyingNameEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameNEQ applies the NEQ predicate on the "underlying_name" field.
func UnderlyingNameNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameIn applies the In predicate on the "underlying_name" field.
func UnderlyingNameIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUnderlyingName), v...))
	})
}

// UnderlyingNameNotIn applies the NotIn predicate on the "underlying_name" field.
func UnderlyingNameNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUnderlyingName), v...))
	})
}

// UnderlyingNameGT applies the GT predicate on the "underlying_name" field.
func UnderlyingNameGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameGTE applies the GTE predicate on the "underlying_name" field.
func UnderlyingNameGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameLT applies the LT predicate on the "underlying_name" field.
func UnderlyingNameLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameLTE applies the LTE predicate on the "underlying_name" field.
func UnderlyingNameLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameContains applies the Contains predicate on the "underlying_name" field.
func UnderlyingNameContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameHasPrefix applies the HasPrefix predicate on the "underlying_name" field.
func UnderlyingNameHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameHasSuffix applies the HasSuffix predicate on the "underlying_name" field.
func UnderlyingNameHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameEqualFold applies the EqualFold predicate on the "underlying_name" field.
func UnderlyingNameEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingNameContainsFold applies the ContainsFold predicate on the "underlying_name" field.
func UnderlyingNameContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUnderlyingName), v))
	})
}

// UnderlyingSymbolEQ applies the EQ predicate on the "underlying_symbol" field.
func UnderlyingSymbolEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolNEQ applies the NEQ predicate on the "underlying_symbol" field.
func UnderlyingSymbolNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolIn applies the In predicate on the "underlying_symbol" field.
func UnderlyingSymbolIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUnderlyingSymbol), v...))
	})
}

// UnderlyingSymbolNotIn applies the NotIn predicate on the "underlying_symbol" field.
func UnderlyingSymbolNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUnderlyingSymbol), v...))
	})
}

// UnderlyingSymbolGT applies the GT predicate on the "underlying_symbol" field.
func UnderlyingSymbolGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolGTE applies the GTE predicate on the "underlying_symbol" field.
func UnderlyingSymbolGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolLT applies the LT predicate on the "underlying_symbol" field.
func UnderlyingSymbolLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolLTE applies the LTE predicate on the "underlying_symbol" field.
func UnderlyingSymbolLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolContains applies the Contains predicate on the "underlying_symbol" field.
func UnderlyingSymbolContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolHasPrefix applies the HasPrefix predicate on the "underlying_symbol" field.
func UnderlyingSymbolHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolHasSuffix applies the HasSuffix predicate on the "underlying_symbol" field.
func UnderlyingSymbolHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolEqualFold applies the EqualFold predicate on the "underlying_symbol" field.
func UnderlyingSymbolEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingSymbolContainsFold applies the ContainsFold predicate on the "underlying_symbol" field.
func UnderlyingSymbolContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUnderlyingSymbol), v))
	})
}

// UnderlyingPriceEQ applies the EQ predicate on the "underlying_price" field.
func UnderlyingPriceEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceNEQ applies the NEQ predicate on the "underlying_price" field.
func UnderlyingPriceNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceIn applies the In predicate on the "underlying_price" field.
func UnderlyingPriceIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUnderlyingPrice), v...))
	})
}

// UnderlyingPriceNotIn applies the NotIn predicate on the "underlying_price" field.
func UnderlyingPriceNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUnderlyingPrice), v...))
	})
}

// UnderlyingPriceGT applies the GT predicate on the "underlying_price" field.
func UnderlyingPriceGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceGTE applies the GTE predicate on the "underlying_price" field.
func UnderlyingPriceGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceLT applies the LT predicate on the "underlying_price" field.
func UnderlyingPriceLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceLTE applies the LTE predicate on the "underlying_price" field.
func UnderlyingPriceLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceContains applies the Contains predicate on the "underlying_price" field.
func UnderlyingPriceContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceHasPrefix applies the HasPrefix predicate on the "underlying_price" field.
func UnderlyingPriceHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceHasSuffix applies the HasSuffix predicate on the "underlying_price" field.
func UnderlyingPriceHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceEqualFold applies the EqualFold predicate on the "underlying_price" field.
func UnderlyingPriceEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingPriceContainsFold applies the ContainsFold predicate on the "underlying_price" field.
func UnderlyingPriceContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUnderlyingPrice), v))
	})
}

// UnderlyingDecimalsEQ applies the EQ predicate on the "underlying_decimals" field.
func UnderlyingDecimalsEQ(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingDecimals), v))
	})
}

// UnderlyingDecimalsNEQ applies the NEQ predicate on the "underlying_decimals" field.
func UnderlyingDecimalsNEQ(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUnderlyingDecimals), v))
	})
}

// UnderlyingDecimalsIn applies the In predicate on the "underlying_decimals" field.
func UnderlyingDecimalsIn(vs ...uint32) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUnderlyingDecimals), v...))
	})
}

// UnderlyingDecimalsNotIn applies the NotIn predicate on the "underlying_decimals" field.
func UnderlyingDecimalsNotIn(vs ...uint32) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUnderlyingDecimals), v...))
	})
}

// UnderlyingDecimalsGT applies the GT predicate on the "underlying_decimals" field.
func UnderlyingDecimalsGT(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUnderlyingDecimals), v))
	})
}

// UnderlyingDecimalsGTE applies the GTE predicate on the "underlying_decimals" field.
func UnderlyingDecimalsGTE(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUnderlyingDecimals), v))
	})
}

// UnderlyingDecimalsLT applies the LT predicate on the "underlying_decimals" field.
func UnderlyingDecimalsLT(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUnderlyingDecimals), v))
	})
}

// UnderlyingDecimalsLTE applies the LTE predicate on the "underlying_decimals" field.
func UnderlyingDecimalsLTE(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUnderlyingDecimals), v))
	})
}

// UnderlyingPriceUsdEQ applies the EQ predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdNEQ applies the NEQ predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdNEQ(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdIn applies the In predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUnderlyingPriceUsd), v...))
	})
}

// UnderlyingPriceUsdNotIn applies the NotIn predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdNotIn(vs ...string) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUnderlyingPriceUsd), v...))
	})
}

// UnderlyingPriceUsdGT applies the GT predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdGT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdGTE applies the GTE predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdGTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdLT applies the LT predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdLT(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdLTE applies the LTE predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdLTE(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdContains applies the Contains predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdContains(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdHasPrefix applies the HasPrefix predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdHasPrefix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdHasSuffix applies the HasSuffix predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdHasSuffix(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdEqualFold applies the EqualFold predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdEqualFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// UnderlyingPriceUsdContainsFold applies the ContainsFold predicate on the "underlying_price_usd" field.
func UnderlyingPriceUsdContainsFold(v string) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUnderlyingPriceUsd), v))
	})
}

// BlockNumberEQ applies the EQ predicate on the "block_number" field.
func BlockNumberEQ(v uint64) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBlockNumber), v))
	})
}

// BlockNumberNEQ applies the NEQ predicate on the "block_number" field.
func BlockNumberNEQ(v uint64) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBlockNumber), v))
	})
}

// BlockNumberIn applies the In predicate on the "block_number" field.
func BlockNumberIn(vs ...uint64) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBlockNumber), v...))
	})
}

// BlockNumberNotIn applies the NotIn predicate on the "block_number" field.
func BlockNumberNotIn(vs ...uint64) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBlockNumber), v...))
	})
}

// BlockNumberGT applies the GT predicate on the "block_number" field.
func BlockNumberGT(v uint64) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBlockNumber), v))
	})
}

// BlockNumberGTE applies the GTE predicate on the "block_number" field.
func BlockNumberGTE(v uint64) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBlockNumber), v))
	})
}

// BlockNumberLT applies the LT predicate on the "block_number" field.
func BlockNumberLT(v uint64) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBlockNumber), v))
	})
}

// BlockNumberLTE applies the LTE predicate on the "block_number" field.
func BlockNumberLTE(v uint64) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBlockNumber), v))
	})
}

// BlockTimestampEQ applies the EQ predicate on the "block_timestamp" field.
func BlockTimestampEQ(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBlockTimestamp), v))
	})
}

// BlockTimestampNEQ applies the NEQ predicate on the "block_timestamp" field.
func BlockTimestampNEQ(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBlockTimestamp), v))
	})
}

// BlockTimestampIn applies the In predicate on the "block_timestamp" field.
func BlockTimestampIn(vs ...uint32) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBlockTimestamp), v...))
	})
}

// BlockTimestampNotIn applies the NotIn predicate on the "block_timestamp" field.
func BlockTimestampNotIn(vs ...uint32) predicate.Market {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Market(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBlockTimestamp), v...))
	})
}

// BlockTimestampGT applies the GT predicate on the "block_timestamp" field.
func BlockTimestampGT(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBlockTimestamp), v))
	})
}

// BlockTimestampGTE applies the GTE predicate on the "block_timestamp" field.
func BlockTimestampGTE(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBlockTimestamp), v))
	})
}

// BlockTimestampLT applies the LT predicate on the "block_timestamp" field.
func BlockTimestampLT(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBlockTimestamp), v))
	})
}

// BlockTimestampLTE applies the LTE predicate on the "block_timestamp" field.
func BlockTimestampLTE(v uint32) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBlockTimestamp), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Market) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Market) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Market) predicate.Market {
	return predicate.Market(func(s *sql.Selector) {
		p(s.Not())
	})
}
