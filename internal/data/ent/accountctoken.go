// Code generated by entc, DO NOT EDIT.

package ent

import (
	"compound/internal/data/ent/account"
	"compound/internal/data/ent/accountctoken"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// AccountCToken is the model entity for the AccountCToken schema.
type AccountCToken struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime time.Time `json:"create_time,omitempty"`
	// UpdateTime holds the value of the "update_time" field.
	UpdateTime time.Time `json:"update_time,omitempty"`
	// User holds the value of the "user" field.
	// 用户地址
	User string `json:"user,omitempty"`
	// Address holds the value of the "address" field.
	// ctoken地址
	Address string `json:"address,omitempty"`
	// Symbol holds the value of the "symbol" field.
	// ctoken symbol
	Symbol string `json:"symbol,omitempty"`
	// Name holds the value of the "name" field.
	// ctoken name
	Name string `json:"name,omitempty"`
	// EnteredMarket holds the value of the "entered_market" field.
	// 进入市场的标志
	EnteredMarket bool `json:"entered_market,omitempty"`
	// CtokenBalance holds the value of the "ctoken_balance" field.
	// ctoken 余额
	CtokenBalance string `json:"ctoken_balance,omitempty"`
	// StoredBorrowBalance holds the value of the "stored_borrow_balance" field.
	// 借款的余额
	StoredBorrowBalance string `json:"stored_borrow_balance,omitempty"`
	// BorrowIndex holds the value of the "borrow_index" field.
	// 用户上一次的贷款指数
	BorrowIndex string `json:"borrow_index,omitempty"`
	// TotalUnderlyingSupplied holds the value of the "total_underlying_supplied" field.
	// 总的token 供应量
	TotalUnderlyingSupplied string `json:"total_underlying_supplied,omitempty"`
	// TotalUnderlyingRedeemed holds the value of the "total_underlying_redeemed" field.
	// 累计提现
	TotalUnderlyingRedeemed string `json:"total_underlying_redeemed,omitempty"`
	// TotalUnderlyingBorrowed holds the value of the "total_underlying_borrowed" field.
	// 累计借款
	TotalUnderlyingBorrowed string `json:"total_underlying_borrowed,omitempty"`
	// TotalUnderlyingRepaid holds the value of the "total_underlying_repaid" field.
	// 累计还款
	TotalUnderlyingRepaid string `json:"total_underlying_repaid,omitempty"`
	// SupplyBalanceUnderlying holds the value of the "supply_balance_underlying" field.
	// 转换为基础代币的 cTokenBalance * market.exchangeRate
	SupplyBalanceUnderlying string `json:"supply_balance_underlying,omitempty"`
	// BorrowBalanceUnderlying holds the value of the "borrow_balance_underlying" field.
	// token的借款 borrowBalanceUnderlying = storedBorrowBalance * market.borrowIndex / accountBorrowIndex
	BorrowBalanceUnderlying string `json:"borrow_balance_underlying,omitempty"`
	// LifetimeSupplyInterestAccrued holds the value of the "lifetime_supply_interest_accrued" field.
	// 累积的供应利息 lifetimeSupplyInterestAccrued = supplyBalanceUnderlying - totalUnderlyingSupplied + totalUnderlyingRedeemed
	LifetimeSupplyInterestAccrued string `json:"lifetime_supply_interest_accrued,omitempty"`
	// LifetimeBorrowInterestAccrued holds the value of the "lifetime_borrow_interest_accrued" field.
	// 生命周期内应计的借款利息金额 lifetimeSupplyInterestAccrued = supplyBalanceUnderlying - totalUnderlyingSupplied + totalUnderlyingRedeemed
	LifetimeBorrowInterestAccrued string `json:"lifetime_borrow_interest_accrued,omitempty"`
	// SafeWithdrawAmountUnderlying holds the value of the "safe_withdraw_amount_underlying" field.
	// 可以提取的供应量，以使用户的健康保持在 1.25 或更高
	SafeWithdrawAmountUnderlying string `json:"safe_withdraw_amount_underlying,omitempty"`
	// CollateralValueInUsd holds the value of the "collateral_value_in_usd" field.
	// 抵押物价值，usd计价
	CollateralValueInUsd string `json:"collateral_value_in_usd,omitempty"`
	// BorrowValueInUsd holds the value of the "borrow_value_in_usd" field.
	// 贷款价值，usd计价
	BorrowValueInUsd string `json:"borrow_value_in_usd,omitempty"`
	// UnderlyingPriceUsd holds the value of the "underlying_price_usd" field.
	// usd价格
	UnderlyingPriceUsd string `json:"underlying_price_usd,omitempty"`
	// BlockNumber holds the value of the "block_number" field.
	// 区块高度
	BlockNumber uint64 `json:"block_number,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the AccountCTokenQuery when eager-loading is set.
	Edges          AccountCTokenEdges `json:"edges"`
	account_tokens *int
}

// AccountCTokenEdges holds the relations/edges for other nodes in the graph.
type AccountCTokenEdges struct {
	// Account holds the value of the account edge.
	Account *Account `json:"account,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// AccountOrErr returns the Account value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AccountCTokenEdges) AccountOrErr() (*Account, error) {
	if e.loadedTypes[0] {
		if e.Account == nil {
			// The edge account was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: account.Label}
		}
		return e.Account, nil
	}
	return nil, &NotLoadedError{edge: "account"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*AccountCToken) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case accountctoken.FieldEnteredMarket:
			values[i] = new(sql.NullBool)
		case accountctoken.FieldID, accountctoken.FieldBlockNumber:
			values[i] = new(sql.NullInt64)
		case accountctoken.FieldUser, accountctoken.FieldAddress, accountctoken.FieldSymbol, accountctoken.FieldName, accountctoken.FieldCtokenBalance, accountctoken.FieldStoredBorrowBalance, accountctoken.FieldBorrowIndex, accountctoken.FieldTotalUnderlyingSupplied, accountctoken.FieldTotalUnderlyingRedeemed, accountctoken.FieldTotalUnderlyingBorrowed, accountctoken.FieldTotalUnderlyingRepaid, accountctoken.FieldSupplyBalanceUnderlying, accountctoken.FieldBorrowBalanceUnderlying, accountctoken.FieldLifetimeSupplyInterestAccrued, accountctoken.FieldLifetimeBorrowInterestAccrued, accountctoken.FieldSafeWithdrawAmountUnderlying, accountctoken.FieldCollateralValueInUsd, accountctoken.FieldBorrowValueInUsd, accountctoken.FieldUnderlyingPriceUsd:
			values[i] = new(sql.NullString)
		case accountctoken.FieldCreateTime, accountctoken.FieldUpdateTime:
			values[i] = new(sql.NullTime)
		case accountctoken.ForeignKeys[0]: // account_tokens
			values[i] = new(sql.NullInt64)
		default:
			return nil, fmt.Errorf("unexpected column %q for type AccountCToken", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the AccountCToken fields.
func (ac *AccountCToken) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case accountctoken.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			ac.ID = int(value.Int64)
		case accountctoken.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				ac.CreateTime = value.Time
			}
		case accountctoken.FieldUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field update_time", values[i])
			} else if value.Valid {
				ac.UpdateTime = value.Time
			}
		case accountctoken.FieldUser:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field user", values[i])
			} else if value.Valid {
				ac.User = value.String
			}
		case accountctoken.FieldAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field address", values[i])
			} else if value.Valid {
				ac.Address = value.String
			}
		case accountctoken.FieldSymbol:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field symbol", values[i])
			} else if value.Valid {
				ac.Symbol = value.String
			}
		case accountctoken.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				ac.Name = value.String
			}
		case accountctoken.FieldEnteredMarket:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field entered_market", values[i])
			} else if value.Valid {
				ac.EnteredMarket = value.Bool
			}
		case accountctoken.FieldCtokenBalance:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ctoken_balance", values[i])
			} else if value.Valid {
				ac.CtokenBalance = value.String
			}
		case accountctoken.FieldStoredBorrowBalance:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field stored_borrow_balance", values[i])
			} else if value.Valid {
				ac.StoredBorrowBalance = value.String
			}
		case accountctoken.FieldBorrowIndex:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field borrow_index", values[i])
			} else if value.Valid {
				ac.BorrowIndex = value.String
			}
		case accountctoken.FieldTotalUnderlyingSupplied:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field total_underlying_supplied", values[i])
			} else if value.Valid {
				ac.TotalUnderlyingSupplied = value.String
			}
		case accountctoken.FieldTotalUnderlyingRedeemed:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field total_underlying_redeemed", values[i])
			} else if value.Valid {
				ac.TotalUnderlyingRedeemed = value.String
			}
		case accountctoken.FieldTotalUnderlyingBorrowed:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field total_underlying_borrowed", values[i])
			} else if value.Valid {
				ac.TotalUnderlyingBorrowed = value.String
			}
		case accountctoken.FieldTotalUnderlyingRepaid:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field total_underlying_repaid", values[i])
			} else if value.Valid {
				ac.TotalUnderlyingRepaid = value.String
			}
		case accountctoken.FieldSupplyBalanceUnderlying:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field supply_balance_underlying", values[i])
			} else if value.Valid {
				ac.SupplyBalanceUnderlying = value.String
			}
		case accountctoken.FieldBorrowBalanceUnderlying:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field borrow_balance_underlying", values[i])
			} else if value.Valid {
				ac.BorrowBalanceUnderlying = value.String
			}
		case accountctoken.FieldLifetimeSupplyInterestAccrued:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field lifetime_supply_interest_accrued", values[i])
			} else if value.Valid {
				ac.LifetimeSupplyInterestAccrued = value.String
			}
		case accountctoken.FieldLifetimeBorrowInterestAccrued:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field lifetime_borrow_interest_accrued", values[i])
			} else if value.Valid {
				ac.LifetimeBorrowInterestAccrued = value.String
			}
		case accountctoken.FieldSafeWithdrawAmountUnderlying:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field safe_withdraw_amount_underlying", values[i])
			} else if value.Valid {
				ac.SafeWithdrawAmountUnderlying = value.String
			}
		case accountctoken.FieldCollateralValueInUsd:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field collateral_value_in_usd", values[i])
			} else if value.Valid {
				ac.CollateralValueInUsd = value.String
			}
		case accountctoken.FieldBorrowValueInUsd:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field borrow_value_in_usd", values[i])
			} else if value.Valid {
				ac.BorrowValueInUsd = value.String
			}
		case accountctoken.FieldUnderlyingPriceUsd:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field underlying_price_usd", values[i])
			} else if value.Valid {
				ac.UnderlyingPriceUsd = value.String
			}
		case accountctoken.FieldBlockNumber:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field block_number", values[i])
			} else if value.Valid {
				ac.BlockNumber = uint64(value.Int64)
			}
		case accountctoken.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field account_tokens", value)
			} else if value.Valid {
				ac.account_tokens = new(int)
				*ac.account_tokens = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryAccount queries the "account" edge of the AccountCToken entity.
func (ac *AccountCToken) QueryAccount() *AccountQuery {
	return (&AccountCTokenClient{config: ac.config}).QueryAccount(ac)
}

// Update returns a builder for updating this AccountCToken.
// Note that you need to call AccountCToken.Unwrap() before calling this method if this AccountCToken
// was returned from a transaction, and the transaction was committed or rolled back.
func (ac *AccountCToken) Update() *AccountCTokenUpdateOne {
	return (&AccountCTokenClient{config: ac.config}).UpdateOne(ac)
}

// Unwrap unwraps the AccountCToken entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ac *AccountCToken) Unwrap() *AccountCToken {
	tx, ok := ac.config.driver.(*txDriver)
	if !ok {
		panic("ent: AccountCToken is not a transactional entity")
	}
	ac.config.driver = tx.drv
	return ac
}

// String implements the fmt.Stringer.
func (ac *AccountCToken) String() string {
	var builder strings.Builder
	builder.WriteString("AccountCToken(")
	builder.WriteString(fmt.Sprintf("id=%v", ac.ID))
	builder.WriteString(", create_time=")
	builder.WriteString(ac.CreateTime.Format(time.ANSIC))
	builder.WriteString(", update_time=")
	builder.WriteString(ac.UpdateTime.Format(time.ANSIC))
	builder.WriteString(", user=")
	builder.WriteString(ac.User)
	builder.WriteString(", address=")
	builder.WriteString(ac.Address)
	builder.WriteString(", symbol=")
	builder.WriteString(ac.Symbol)
	builder.WriteString(", name=")
	builder.WriteString(ac.Name)
	builder.WriteString(", entered_market=")
	builder.WriteString(fmt.Sprintf("%v", ac.EnteredMarket))
	builder.WriteString(", ctoken_balance=")
	builder.WriteString(ac.CtokenBalance)
	builder.WriteString(", stored_borrow_balance=")
	builder.WriteString(ac.StoredBorrowBalance)
	builder.WriteString(", borrow_index=")
	builder.WriteString(ac.BorrowIndex)
	builder.WriteString(", total_underlying_supplied=")
	builder.WriteString(ac.TotalUnderlyingSupplied)
	builder.WriteString(", total_underlying_redeemed=")
	builder.WriteString(ac.TotalUnderlyingRedeemed)
	builder.WriteString(", total_underlying_borrowed=")
	builder.WriteString(ac.TotalUnderlyingBorrowed)
	builder.WriteString(", total_underlying_repaid=")
	builder.WriteString(ac.TotalUnderlyingRepaid)
	builder.WriteString(", supply_balance_underlying=")
	builder.WriteString(ac.SupplyBalanceUnderlying)
	builder.WriteString(", borrow_balance_underlying=")
	builder.WriteString(ac.BorrowBalanceUnderlying)
	builder.WriteString(", lifetime_supply_interest_accrued=")
	builder.WriteString(ac.LifetimeSupplyInterestAccrued)
	builder.WriteString(", lifetime_borrow_interest_accrued=")
	builder.WriteString(ac.LifetimeBorrowInterestAccrued)
	builder.WriteString(", safe_withdraw_amount_underlying=")
	builder.WriteString(ac.SafeWithdrawAmountUnderlying)
	builder.WriteString(", collateral_value_in_usd=")
	builder.WriteString(ac.CollateralValueInUsd)
	builder.WriteString(", borrow_value_in_usd=")
	builder.WriteString(ac.BorrowValueInUsd)
	builder.WriteString(", underlying_price_usd=")
	builder.WriteString(ac.UnderlyingPriceUsd)
	builder.WriteString(", block_number=")
	builder.WriteString(fmt.Sprintf("%v", ac.BlockNumber))
	builder.WriteByte(')')
	return builder.String()
}

// AccountCTokens is a parsable slice of AccountCToken.
type AccountCTokens []*AccountCToken

func (ac AccountCTokens) config(cfg config) {
	for _i := range ac {
		ac[_i].config = cfg
	}
}
