// Code generated by entc, DO NOT EDIT.

package ent

import (
	"compound/internal/data/ent/account"
	"compound/internal/data/ent/accountctoken"
	"compound/internal/data/ent/market"
	"compound/internal/data/ent/predicate"
	"compound/internal/data/ent/preference"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount       = "Account"
	TypeAccountCToken = "AccountCToken"
	TypeMarket        = "Market"
	TypePreference    = "Preference"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	address                       *string
	has_borrowed                  *bool
	count_liquidated              *uint32
	addcount_liquidated           *int32
	count_liquidator              *uint32
	addcount_liquidator           *int32
	health                        *string
	total_collateral_value_in_usd *string
	total_borrow_value_in_usd     *string
	block_number                  *uint64
	addblock_number               *int64
	clearedFields                 map[string]struct{}
	tokens                        map[int]struct{}
	removedtokens                 map[int]struct{}
	clearedtokens                 bool
	done                          bool
	oldValue                      func(context.Context) (*Account, error)
	predicates                    []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AccountMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccountMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccountMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccountMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccountMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccountMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAddress sets the "address" field.
func (m *AccountMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AccountMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AccountMutation) ResetAddress() {
	m.address = nil
}

// SetHasBorrowed sets the "has_borrowed" field.
func (m *AccountMutation) SetHasBorrowed(b bool) {
	m.has_borrowed = &b
}

// HasBorrowed returns the value of the "has_borrowed" field in the mutation.
func (m *AccountMutation) HasBorrowed() (r bool, exists bool) {
	v := m.has_borrowed
	if v == nil {
		return
	}
	return *v, true
}

// OldHasBorrowed returns the old "has_borrowed" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldHasBorrowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasBorrowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasBorrowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasBorrowed: %w", err)
	}
	return oldValue.HasBorrowed, nil
}

// ResetHasBorrowed resets all changes to the "has_borrowed" field.
func (m *AccountMutation) ResetHasBorrowed() {
	m.has_borrowed = nil
}

// SetCountLiquidated sets the "count_liquidated" field.
func (m *AccountMutation) SetCountLiquidated(u uint32) {
	m.count_liquidated = &u
	m.addcount_liquidated = nil
}

// CountLiquidated returns the value of the "count_liquidated" field in the mutation.
func (m *AccountMutation) CountLiquidated() (r uint32, exists bool) {
	v := m.count_liquidated
	if v == nil {
		return
	}
	return *v, true
}

// OldCountLiquidated returns the old "count_liquidated" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCountLiquidated(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountLiquidated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountLiquidated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountLiquidated: %w", err)
	}
	return oldValue.CountLiquidated, nil
}

// AddCountLiquidated adds u to the "count_liquidated" field.
func (m *AccountMutation) AddCountLiquidated(u int32) {
	if m.addcount_liquidated != nil {
		*m.addcount_liquidated += u
	} else {
		m.addcount_liquidated = &u
	}
}

// AddedCountLiquidated returns the value that was added to the "count_liquidated" field in this mutation.
func (m *AccountMutation) AddedCountLiquidated() (r int32, exists bool) {
	v := m.addcount_liquidated
	if v == nil {
		return
	}
	return *v, true
}

// ResetCountLiquidated resets all changes to the "count_liquidated" field.
func (m *AccountMutation) ResetCountLiquidated() {
	m.count_liquidated = nil
	m.addcount_liquidated = nil
}

// SetCountLiquidator sets the "count_liquidator" field.
func (m *AccountMutation) SetCountLiquidator(u uint32) {
	m.count_liquidator = &u
	m.addcount_liquidator = nil
}

// CountLiquidator returns the value of the "count_liquidator" field in the mutation.
func (m *AccountMutation) CountLiquidator() (r uint32, exists bool) {
	v := m.count_liquidator
	if v == nil {
		return
	}
	return *v, true
}

// OldCountLiquidator returns the old "count_liquidator" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCountLiquidator(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountLiquidator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountLiquidator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountLiquidator: %w", err)
	}
	return oldValue.CountLiquidator, nil
}

// AddCountLiquidator adds u to the "count_liquidator" field.
func (m *AccountMutation) AddCountLiquidator(u int32) {
	if m.addcount_liquidator != nil {
		*m.addcount_liquidator += u
	} else {
		m.addcount_liquidator = &u
	}
}

// AddedCountLiquidator returns the value that was added to the "count_liquidator" field in this mutation.
func (m *AccountMutation) AddedCountLiquidator() (r int32, exists bool) {
	v := m.addcount_liquidator
	if v == nil {
		return
	}
	return *v, true
}

// ResetCountLiquidator resets all changes to the "count_liquidator" field.
func (m *AccountMutation) ResetCountLiquidator() {
	m.count_liquidator = nil
	m.addcount_liquidator = nil
}

// SetHealth sets the "health" field.
func (m *AccountMutation) SetHealth(s string) {
	m.health = &s
}

// Health returns the value of the "health" field in the mutation.
func (m *AccountMutation) Health() (r string, exists bool) {
	v := m.health
	if v == nil {
		return
	}
	return *v, true
}

// OldHealth returns the old "health" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldHealth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealth: %w", err)
	}
	return oldValue.Health, nil
}

// ResetHealth resets all changes to the "health" field.
func (m *AccountMutation) ResetHealth() {
	m.health = nil
}

// SetTotalCollateralValueInUsd sets the "total_collateral_value_in_usd" field.
func (m *AccountMutation) SetTotalCollateralValueInUsd(s string) {
	m.total_collateral_value_in_usd = &s
}

// TotalCollateralValueInUsd returns the value of the "total_collateral_value_in_usd" field in the mutation.
func (m *AccountMutation) TotalCollateralValueInUsd() (r string, exists bool) {
	v := m.total_collateral_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCollateralValueInUsd returns the old "total_collateral_value_in_usd" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTotalCollateralValueInUsd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCollateralValueInUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCollateralValueInUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCollateralValueInUsd: %w", err)
	}
	return oldValue.TotalCollateralValueInUsd, nil
}

// ResetTotalCollateralValueInUsd resets all changes to the "total_collateral_value_in_usd" field.
func (m *AccountMutation) ResetTotalCollateralValueInUsd() {
	m.total_collateral_value_in_usd = nil
}

// SetTotalBorrowValueInUsd sets the "total_borrow_value_in_usd" field.
func (m *AccountMutation) SetTotalBorrowValueInUsd(s string) {
	m.total_borrow_value_in_usd = &s
}

// TotalBorrowValueInUsd returns the value of the "total_borrow_value_in_usd" field in the mutation.
func (m *AccountMutation) TotalBorrowValueInUsd() (r string, exists bool) {
	v := m.total_borrow_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalBorrowValueInUsd returns the old "total_borrow_value_in_usd" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTotalBorrowValueInUsd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalBorrowValueInUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalBorrowValueInUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalBorrowValueInUsd: %w", err)
	}
	return oldValue.TotalBorrowValueInUsd, nil
}

// ResetTotalBorrowValueInUsd resets all changes to the "total_borrow_value_in_usd" field.
func (m *AccountMutation) ResetTotalBorrowValueInUsd() {
	m.total_borrow_value_in_usd = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *AccountMutation) SetBlockNumber(u uint64) {
	m.block_number = &u
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *AccountMutation) BlockNumber() (r uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBlockNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds u to the "block_number" field.
func (m *AccountMutation) AddBlockNumber(u int64) {
	if m.addblock_number != nil {
		*m.addblock_number += u
	} else {
		m.addblock_number = &u
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *AccountMutation) AddedBlockNumber() (r int64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *AccountMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// AddTokenIDs adds the "tokens" edge to the AccountCToken entity by ids.
func (m *AccountMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the AccountCToken entity.
func (m *AccountMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the AccountCToken entity was cleared.
func (m *AccountMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the AccountCToken entity by IDs.
func (m *AccountMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the AccountCToken entity.
func (m *AccountMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *AccountMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *AccountMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, account.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, account.FieldUpdateTime)
	}
	if m.address != nil {
		fields = append(fields, account.FieldAddress)
	}
	if m.has_borrowed != nil {
		fields = append(fields, account.FieldHasBorrowed)
	}
	if m.count_liquidated != nil {
		fields = append(fields, account.FieldCountLiquidated)
	}
	if m.count_liquidator != nil {
		fields = append(fields, account.FieldCountLiquidator)
	}
	if m.health != nil {
		fields = append(fields, account.FieldHealth)
	}
	if m.total_collateral_value_in_usd != nil {
		fields = append(fields, account.FieldTotalCollateralValueInUsd)
	}
	if m.total_borrow_value_in_usd != nil {
		fields = append(fields, account.FieldTotalBorrowValueInUsd)
	}
	if m.block_number != nil {
		fields = append(fields, account.FieldBlockNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreateTime:
		return m.CreateTime()
	case account.FieldUpdateTime:
		return m.UpdateTime()
	case account.FieldAddress:
		return m.Address()
	case account.FieldHasBorrowed:
		return m.HasBorrowed()
	case account.FieldCountLiquidated:
		return m.CountLiquidated()
	case account.FieldCountLiquidator:
		return m.CountLiquidator()
	case account.FieldHealth:
		return m.Health()
	case account.FieldTotalCollateralValueInUsd:
		return m.TotalCollateralValueInUsd()
	case account.FieldTotalBorrowValueInUsd:
		return m.TotalBorrowValueInUsd()
	case account.FieldBlockNumber:
		return m.BlockNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case account.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case account.FieldAddress:
		return m.OldAddress(ctx)
	case account.FieldHasBorrowed:
		return m.OldHasBorrowed(ctx)
	case account.FieldCountLiquidated:
		return m.OldCountLiquidated(ctx)
	case account.FieldCountLiquidator:
		return m.OldCountLiquidator(ctx)
	case account.FieldHealth:
		return m.OldHealth(ctx)
	case account.FieldTotalCollateralValueInUsd:
		return m.OldTotalCollateralValueInUsd(ctx)
	case account.FieldTotalBorrowValueInUsd:
		return m.OldTotalBorrowValueInUsd(ctx)
	case account.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case account.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case account.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case account.FieldHasBorrowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasBorrowed(v)
		return nil
	case account.FieldCountLiquidated:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountLiquidated(v)
		return nil
	case account.FieldCountLiquidator:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountLiquidator(v)
		return nil
	case account.FieldHealth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealth(v)
		return nil
	case account.FieldTotalCollateralValueInUsd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCollateralValueInUsd(v)
		return nil
	case account.FieldTotalBorrowValueInUsd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalBorrowValueInUsd(v)
		return nil
	case account.FieldBlockNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addcount_liquidated != nil {
		fields = append(fields, account.FieldCountLiquidated)
	}
	if m.addcount_liquidator != nil {
		fields = append(fields, account.FieldCountLiquidator)
	}
	if m.addblock_number != nil {
		fields = append(fields, account.FieldBlockNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCountLiquidated:
		return m.AddedCountLiquidated()
	case account.FieldCountLiquidator:
		return m.AddedCountLiquidator()
	case account.FieldBlockNumber:
		return m.AddedBlockNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldCountLiquidated:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCountLiquidated(v)
		return nil
	case account.FieldCountLiquidator:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCountLiquidator(v)
		return nil
	case account.FieldBlockNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case account.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case account.FieldAddress:
		m.ResetAddress()
		return nil
	case account.FieldHasBorrowed:
		m.ResetHasBorrowed()
		return nil
	case account.FieldCountLiquidated:
		m.ResetCountLiquidated()
		return nil
	case account.FieldCountLiquidator:
		m.ResetCountLiquidator()
		return nil
	case account.FieldHealth:
		m.ResetHealth()
		return nil
	case account.FieldTotalCollateralValueInUsd:
		m.ResetTotalCollateralValueInUsd()
		return nil
	case account.FieldTotalBorrowValueInUsd:
		m.ResetTotalBorrowValueInUsd()
		return nil
	case account.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tokens != nil {
		edges = append(edges, account.EdgeTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtokens != nil {
		edges = append(edges, account.EdgeTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtokens {
		edges = append(edges, account.EdgeTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeTokens:
		return m.clearedtokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeTokens:
		m.ResetTokens()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AccountCTokenMutation represents an operation that mutates the AccountCToken nodes in the graph.
type AccountCTokenMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	create_time                      *time.Time
	update_time                      *time.Time
	user                             *string
	address                          *string
	symbol                           *string
	name                             *string
	entered_market                   *bool
	ctoken_balance                   *string
	stored_borrow_balance            *string
	borrow_index                     *string
	total_underlying_supplied        *string
	total_underlying_redeemed        *string
	total_underlying_borrowed        *string
	total_underlying_repaid          *string
	supply_balance_underlying        *string
	borrow_balance_underlying        *string
	lifetime_supply_interest_accrued *string
	lifetime_borrow_interest_accrued *string
	safe_withdraw_amount_underlying  *string
	collateral_value_in_usd          *string
	borrow_value_in_usd              *string
	underlying_price_usd             *string
	block_number                     *uint64
	addblock_number                  *int64
	clearedFields                    map[string]struct{}
	account                          *int
	clearedaccount                   bool
	done                             bool
	oldValue                         func(context.Context) (*AccountCToken, error)
	predicates                       []predicate.AccountCToken
}

var _ ent.Mutation = (*AccountCTokenMutation)(nil)

// accountctokenOption allows management of the mutation configuration using functional options.
type accountctokenOption func(*AccountCTokenMutation)

// newAccountCTokenMutation creates new mutation for the AccountCToken entity.
func newAccountCTokenMutation(c config, op Op, opts ...accountctokenOption) *AccountCTokenMutation {
	m := &AccountCTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountCToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountCTokenID sets the ID field of the mutation.
func withAccountCTokenID(id int) accountctokenOption {
	return func(m *AccountCTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountCToken
		)
		m.oldValue = func(ctx context.Context) (*AccountCToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountCToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountCToken sets the old AccountCToken of the mutation.
func withAccountCToken(node *AccountCToken) accountctokenOption {
	return func(m *AccountCTokenMutation) {
		m.oldValue = func(context.Context) (*AccountCToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountCTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountCTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountCTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountCTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountCToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AccountCTokenMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccountCTokenMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccountCTokenMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccountCTokenMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccountCTokenMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccountCTokenMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUser sets the "user" field.
func (m *AccountCTokenMutation) SetUser(s string) {
	m.user = &s
}

// User returns the value of the "user" field in the mutation.
func (m *AccountCTokenMutation) User() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUser returns the old "user" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser: %w", err)
	}
	return oldValue.User, nil
}

// ResetUser resets all changes to the "user" field.
func (m *AccountCTokenMutation) ResetUser() {
	m.user = nil
}

// SetAddress sets the "address" field.
func (m *AccountCTokenMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AccountCTokenMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AccountCTokenMutation) ResetAddress() {
	m.address = nil
}

// SetSymbol sets the "symbol" field.
func (m *AccountCTokenMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *AccountCTokenMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *AccountCTokenMutation) ResetSymbol() {
	m.symbol = nil
}

// SetName sets the "name" field.
func (m *AccountCTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountCTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountCTokenMutation) ResetName() {
	m.name = nil
}

// SetEnteredMarket sets the "entered_market" field.
func (m *AccountCTokenMutation) SetEnteredMarket(b bool) {
	m.entered_market = &b
}

// EnteredMarket returns the value of the "entered_market" field in the mutation.
func (m *AccountCTokenMutation) EnteredMarket() (r bool, exists bool) {
	v := m.entered_market
	if v == nil {
		return
	}
	return *v, true
}

// OldEnteredMarket returns the old "entered_market" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldEnteredMarket(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnteredMarket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnteredMarket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnteredMarket: %w", err)
	}
	return oldValue.EnteredMarket, nil
}

// ResetEnteredMarket resets all changes to the "entered_market" field.
func (m *AccountCTokenMutation) ResetEnteredMarket() {
	m.entered_market = nil
}

// SetCtokenBalance sets the "ctoken_balance" field.
func (m *AccountCTokenMutation) SetCtokenBalance(s string) {
	m.ctoken_balance = &s
}

// CtokenBalance returns the value of the "ctoken_balance" field in the mutation.
func (m *AccountCTokenMutation) CtokenBalance() (r string, exists bool) {
	v := m.ctoken_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldCtokenBalance returns the old "ctoken_balance" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldCtokenBalance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCtokenBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCtokenBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCtokenBalance: %w", err)
	}
	return oldValue.CtokenBalance, nil
}

// ResetCtokenBalance resets all changes to the "ctoken_balance" field.
func (m *AccountCTokenMutation) ResetCtokenBalance() {
	m.ctoken_balance = nil
}

// SetStoredBorrowBalance sets the "stored_borrow_balance" field.
func (m *AccountCTokenMutation) SetStoredBorrowBalance(s string) {
	m.stored_borrow_balance = &s
}

// StoredBorrowBalance returns the value of the "stored_borrow_balance" field in the mutation.
func (m *AccountCTokenMutation) StoredBorrowBalance() (r string, exists bool) {
	v := m.stored_borrow_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldStoredBorrowBalance returns the old "stored_borrow_balance" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldStoredBorrowBalance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoredBorrowBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoredBorrowBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoredBorrowBalance: %w", err)
	}
	return oldValue.StoredBorrowBalance, nil
}

// ResetStoredBorrowBalance resets all changes to the "stored_borrow_balance" field.
func (m *AccountCTokenMutation) ResetStoredBorrowBalance() {
	m.stored_borrow_balance = nil
}

// SetBorrowIndex sets the "borrow_index" field.
func (m *AccountCTokenMutation) SetBorrowIndex(s string) {
	m.borrow_index = &s
}

// BorrowIndex returns the value of the "borrow_index" field in the mutation.
func (m *AccountCTokenMutation) BorrowIndex() (r string, exists bool) {
	v := m.borrow_index
	if v == nil {
		return
	}
	return *v, true
}

// OldBorrowIndex returns the old "borrow_index" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldBorrowIndex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBorrowIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBorrowIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBorrowIndex: %w", err)
	}
	return oldValue.BorrowIndex, nil
}

// ResetBorrowIndex resets all changes to the "borrow_index" field.
func (m *AccountCTokenMutation) ResetBorrowIndex() {
	m.borrow_index = nil
}

// SetTotalUnderlyingSupplied sets the "total_underlying_supplied" field.
func (m *AccountCTokenMutation) SetTotalUnderlyingSupplied(s string) {
	m.total_underlying_supplied = &s
}

// TotalUnderlyingSupplied returns the value of the "total_underlying_supplied" field in the mutation.
func (m *AccountCTokenMutation) TotalUnderlyingSupplied() (r string, exists bool) {
	v := m.total_underlying_supplied
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUnderlyingSupplied returns the old "total_underlying_supplied" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldTotalUnderlyingSupplied(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUnderlyingSupplied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUnderlyingSupplied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUnderlyingSupplied: %w", err)
	}
	return oldValue.TotalUnderlyingSupplied, nil
}

// ResetTotalUnderlyingSupplied resets all changes to the "total_underlying_supplied" field.
func (m *AccountCTokenMutation) ResetTotalUnderlyingSupplied() {
	m.total_underlying_supplied = nil
}

// SetTotalUnderlyingRedeemed sets the "total_underlying_redeemed" field.
func (m *AccountCTokenMutation) SetTotalUnderlyingRedeemed(s string) {
	m.total_underlying_redeemed = &s
}

// TotalUnderlyingRedeemed returns the value of the "total_underlying_redeemed" field in the mutation.
func (m *AccountCTokenMutation) TotalUnderlyingRedeemed() (r string, exists bool) {
	v := m.total_underlying_redeemed
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUnderlyingRedeemed returns the old "total_underlying_redeemed" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldTotalUnderlyingRedeemed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUnderlyingRedeemed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUnderlyingRedeemed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUnderlyingRedeemed: %w", err)
	}
	return oldValue.TotalUnderlyingRedeemed, nil
}

// ResetTotalUnderlyingRedeemed resets all changes to the "total_underlying_redeemed" field.
func (m *AccountCTokenMutation) ResetTotalUnderlyingRedeemed() {
	m.total_underlying_redeemed = nil
}

// SetTotalUnderlyingBorrowed sets the "total_underlying_borrowed" field.
func (m *AccountCTokenMutation) SetTotalUnderlyingBorrowed(s string) {
	m.total_underlying_borrowed = &s
}

// TotalUnderlyingBorrowed returns the value of the "total_underlying_borrowed" field in the mutation.
func (m *AccountCTokenMutation) TotalUnderlyingBorrowed() (r string, exists bool) {
	v := m.total_underlying_borrowed
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUnderlyingBorrowed returns the old "total_underlying_borrowed" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldTotalUnderlyingBorrowed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUnderlyingBorrowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUnderlyingBorrowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUnderlyingBorrowed: %w", err)
	}
	return oldValue.TotalUnderlyingBorrowed, nil
}

// ResetTotalUnderlyingBorrowed resets all changes to the "total_underlying_borrowed" field.
func (m *AccountCTokenMutation) ResetTotalUnderlyingBorrowed() {
	m.total_underlying_borrowed = nil
}

// SetTotalUnderlyingRepaid sets the "total_underlying_repaid" field.
func (m *AccountCTokenMutation) SetTotalUnderlyingRepaid(s string) {
	m.total_underlying_repaid = &s
}

// TotalUnderlyingRepaid returns the value of the "total_underlying_repaid" field in the mutation.
func (m *AccountCTokenMutation) TotalUnderlyingRepaid() (r string, exists bool) {
	v := m.total_underlying_repaid
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUnderlyingRepaid returns the old "total_underlying_repaid" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldTotalUnderlyingRepaid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUnderlyingRepaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUnderlyingRepaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUnderlyingRepaid: %w", err)
	}
	return oldValue.TotalUnderlyingRepaid, nil
}

// ResetTotalUnderlyingRepaid resets all changes to the "total_underlying_repaid" field.
func (m *AccountCTokenMutation) ResetTotalUnderlyingRepaid() {
	m.total_underlying_repaid = nil
}

// SetSupplyBalanceUnderlying sets the "supply_balance_underlying" field.
func (m *AccountCTokenMutation) SetSupplyBalanceUnderlying(s string) {
	m.supply_balance_underlying = &s
}

// SupplyBalanceUnderlying returns the value of the "supply_balance_underlying" field in the mutation.
func (m *AccountCTokenMutation) SupplyBalanceUnderlying() (r string, exists bool) {
	v := m.supply_balance_underlying
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplyBalanceUnderlying returns the old "supply_balance_underlying" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldSupplyBalanceUnderlying(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplyBalanceUnderlying is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplyBalanceUnderlying requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplyBalanceUnderlying: %w", err)
	}
	return oldValue.SupplyBalanceUnderlying, nil
}

// ResetSupplyBalanceUnderlying resets all changes to the "supply_balance_underlying" field.
func (m *AccountCTokenMutation) ResetSupplyBalanceUnderlying() {
	m.supply_balance_underlying = nil
}

// SetBorrowBalanceUnderlying sets the "borrow_balance_underlying" field.
func (m *AccountCTokenMutation) SetBorrowBalanceUnderlying(s string) {
	m.borrow_balance_underlying = &s
}

// BorrowBalanceUnderlying returns the value of the "borrow_balance_underlying" field in the mutation.
func (m *AccountCTokenMutation) BorrowBalanceUnderlying() (r string, exists bool) {
	v := m.borrow_balance_underlying
	if v == nil {
		return
	}
	return *v, true
}

// OldBorrowBalanceUnderlying returns the old "borrow_balance_underlying" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldBorrowBalanceUnderlying(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBorrowBalanceUnderlying is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBorrowBalanceUnderlying requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBorrowBalanceUnderlying: %w", err)
	}
	return oldValue.BorrowBalanceUnderlying, nil
}

// ResetBorrowBalanceUnderlying resets all changes to the "borrow_balance_underlying" field.
func (m *AccountCTokenMutation) ResetBorrowBalanceUnderlying() {
	m.borrow_balance_underlying = nil
}

// SetLifetimeSupplyInterestAccrued sets the "lifetime_supply_interest_accrued" field.
func (m *AccountCTokenMutation) SetLifetimeSupplyInterestAccrued(s string) {
	m.lifetime_supply_interest_accrued = &s
}

// LifetimeSupplyInterestAccrued returns the value of the "lifetime_supply_interest_accrued" field in the mutation.
func (m *AccountCTokenMutation) LifetimeSupplyInterestAccrued() (r string, exists bool) {
	v := m.lifetime_supply_interest_accrued
	if v == nil {
		return
	}
	return *v, true
}

// OldLifetimeSupplyInterestAccrued returns the old "lifetime_supply_interest_accrued" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldLifetimeSupplyInterestAccrued(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifetimeSupplyInterestAccrued is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifetimeSupplyInterestAccrued requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifetimeSupplyInterestAccrued: %w", err)
	}
	return oldValue.LifetimeSupplyInterestAccrued, nil
}

// ResetLifetimeSupplyInterestAccrued resets all changes to the "lifetime_supply_interest_accrued" field.
func (m *AccountCTokenMutation) ResetLifetimeSupplyInterestAccrued() {
	m.lifetime_supply_interest_accrued = nil
}

// SetLifetimeBorrowInterestAccrued sets the "lifetime_borrow_interest_accrued" field.
func (m *AccountCTokenMutation) SetLifetimeBorrowInterestAccrued(s string) {
	m.lifetime_borrow_interest_accrued = &s
}

// LifetimeBorrowInterestAccrued returns the value of the "lifetime_borrow_interest_accrued" field in the mutation.
func (m *AccountCTokenMutation) LifetimeBorrowInterestAccrued() (r string, exists bool) {
	v := m.lifetime_borrow_interest_accrued
	if v == nil {
		return
	}
	return *v, true
}

// OldLifetimeBorrowInterestAccrued returns the old "lifetime_borrow_interest_accrued" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldLifetimeBorrowInterestAccrued(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifetimeBorrowInterestAccrued is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifetimeBorrowInterestAccrued requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifetimeBorrowInterestAccrued: %w", err)
	}
	return oldValue.LifetimeBorrowInterestAccrued, nil
}

// ResetLifetimeBorrowInterestAccrued resets all changes to the "lifetime_borrow_interest_accrued" field.
func (m *AccountCTokenMutation) ResetLifetimeBorrowInterestAccrued() {
	m.lifetime_borrow_interest_accrued = nil
}

// SetSafeWithdrawAmountUnderlying sets the "safe_withdraw_amount_underlying" field.
func (m *AccountCTokenMutation) SetSafeWithdrawAmountUnderlying(s string) {
	m.safe_withdraw_amount_underlying = &s
}

// SafeWithdrawAmountUnderlying returns the value of the "safe_withdraw_amount_underlying" field in the mutation.
func (m *AccountCTokenMutation) SafeWithdrawAmountUnderlying() (r string, exists bool) {
	v := m.safe_withdraw_amount_underlying
	if v == nil {
		return
	}
	return *v, true
}

// OldSafeWithdrawAmountUnderlying returns the old "safe_withdraw_amount_underlying" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldSafeWithdrawAmountUnderlying(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSafeWithdrawAmountUnderlying is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSafeWithdrawAmountUnderlying requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSafeWithdrawAmountUnderlying: %w", err)
	}
	return oldValue.SafeWithdrawAmountUnderlying, nil
}

// ResetSafeWithdrawAmountUnderlying resets all changes to the "safe_withdraw_amount_underlying" field.
func (m *AccountCTokenMutation) ResetSafeWithdrawAmountUnderlying() {
	m.safe_withdraw_amount_underlying = nil
}

// SetCollateralValueInUsd sets the "collateral_value_in_usd" field.
func (m *AccountCTokenMutation) SetCollateralValueInUsd(s string) {
	m.collateral_value_in_usd = &s
}

// CollateralValueInUsd returns the value of the "collateral_value_in_usd" field in the mutation.
func (m *AccountCTokenMutation) CollateralValueInUsd() (r string, exists bool) {
	v := m.collateral_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldCollateralValueInUsd returns the old "collateral_value_in_usd" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldCollateralValueInUsd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollateralValueInUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollateralValueInUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollateralValueInUsd: %w", err)
	}
	return oldValue.CollateralValueInUsd, nil
}

// ResetCollateralValueInUsd resets all changes to the "collateral_value_in_usd" field.
func (m *AccountCTokenMutation) ResetCollateralValueInUsd() {
	m.collateral_value_in_usd = nil
}

// SetBorrowValueInUsd sets the "borrow_value_in_usd" field.
func (m *AccountCTokenMutation) SetBorrowValueInUsd(s string) {
	m.borrow_value_in_usd = &s
}

// BorrowValueInUsd returns the value of the "borrow_value_in_usd" field in the mutation.
func (m *AccountCTokenMutation) BorrowValueInUsd() (r string, exists bool) {
	v := m.borrow_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldBorrowValueInUsd returns the old "borrow_value_in_usd" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldBorrowValueInUsd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBorrowValueInUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBorrowValueInUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBorrowValueInUsd: %w", err)
	}
	return oldValue.BorrowValueInUsd, nil
}

// ResetBorrowValueInUsd resets all changes to the "borrow_value_in_usd" field.
func (m *AccountCTokenMutation) ResetBorrowValueInUsd() {
	m.borrow_value_in_usd = nil
}

// SetUnderlyingPriceUsd sets the "underlying_price_usd" field.
func (m *AccountCTokenMutation) SetUnderlyingPriceUsd(s string) {
	m.underlying_price_usd = &s
}

// UnderlyingPriceUsd returns the value of the "underlying_price_usd" field in the mutation.
func (m *AccountCTokenMutation) UnderlyingPriceUsd() (r string, exists bool) {
	v := m.underlying_price_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldUnderlyingPriceUsd returns the old "underlying_price_usd" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldUnderlyingPriceUsd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnderlyingPriceUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnderlyingPriceUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnderlyingPriceUsd: %w", err)
	}
	return oldValue.UnderlyingPriceUsd, nil
}

// ResetUnderlyingPriceUsd resets all changes to the "underlying_price_usd" field.
func (m *AccountCTokenMutation) ResetUnderlyingPriceUsd() {
	m.underlying_price_usd = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *AccountCTokenMutation) SetBlockNumber(u uint64) {
	m.block_number = &u
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *AccountCTokenMutation) BlockNumber() (r uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the AccountCToken entity.
// If the AccountCToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountCTokenMutation) OldBlockNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds u to the "block_number" field.
func (m *AccountCTokenMutation) AddBlockNumber(u int64) {
	if m.addblock_number != nil {
		*m.addblock_number += u
	} else {
		m.addblock_number = &u
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *AccountCTokenMutation) AddedBlockNumber() (r int64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *AccountCTokenMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *AccountCTokenMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AccountCTokenMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AccountCTokenMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *AccountCTokenMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AccountCTokenMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AccountCTokenMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the AccountCTokenMutation builder.
func (m *AccountCTokenMutation) Where(ps ...predicate.AccountCToken) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountCTokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AccountCToken).
func (m *AccountCTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountCTokenMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.create_time != nil {
		fields = append(fields, accountctoken.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, accountctoken.FieldUpdateTime)
	}
	if m.user != nil {
		fields = append(fields, accountctoken.FieldUser)
	}
	if m.address != nil {
		fields = append(fields, accountctoken.FieldAddress)
	}
	if m.symbol != nil {
		fields = append(fields, accountctoken.FieldSymbol)
	}
	if m.name != nil {
		fields = append(fields, accountctoken.FieldName)
	}
	if m.entered_market != nil {
		fields = append(fields, accountctoken.FieldEnteredMarket)
	}
	if m.ctoken_balance != nil {
		fields = append(fields, accountctoken.FieldCtokenBalance)
	}
	if m.stored_borrow_balance != nil {
		fields = append(fields, accountctoken.FieldStoredBorrowBalance)
	}
	if m.borrow_index != nil {
		fields = append(fields, accountctoken.FieldBorrowIndex)
	}
	if m.total_underlying_supplied != nil {
		fields = append(fields, accountctoken.FieldTotalUnderlyingSupplied)
	}
	if m.total_underlying_redeemed != nil {
		fields = append(fields, accountctoken.FieldTotalUnderlyingRedeemed)
	}
	if m.total_underlying_borrowed != nil {
		fields = append(fields, accountctoken.FieldTotalUnderlyingBorrowed)
	}
	if m.total_underlying_repaid != nil {
		fields = append(fields, accountctoken.FieldTotalUnderlyingRepaid)
	}
	if m.supply_balance_underlying != nil {
		fields = append(fields, accountctoken.FieldSupplyBalanceUnderlying)
	}
	if m.borrow_balance_underlying != nil {
		fields = append(fields, accountctoken.FieldBorrowBalanceUnderlying)
	}
	if m.lifetime_supply_interest_accrued != nil {
		fields = append(fields, accountctoken.FieldLifetimeSupplyInterestAccrued)
	}
	if m.lifetime_borrow_interest_accrued != nil {
		fields = append(fields, accountctoken.FieldLifetimeBorrowInterestAccrued)
	}
	if m.safe_withdraw_amount_underlying != nil {
		fields = append(fields, accountctoken.FieldSafeWithdrawAmountUnderlying)
	}
	if m.collateral_value_in_usd != nil {
		fields = append(fields, accountctoken.FieldCollateralValueInUsd)
	}
	if m.borrow_value_in_usd != nil {
		fields = append(fields, accountctoken.FieldBorrowValueInUsd)
	}
	if m.underlying_price_usd != nil {
		fields = append(fields, accountctoken.FieldUnderlyingPriceUsd)
	}
	if m.block_number != nil {
		fields = append(fields, accountctoken.FieldBlockNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountCTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountctoken.FieldCreateTime:
		return m.CreateTime()
	case accountctoken.FieldUpdateTime:
		return m.UpdateTime()
	case accountctoken.FieldUser:
		return m.User()
	case accountctoken.FieldAddress:
		return m.Address()
	case accountctoken.FieldSymbol:
		return m.Symbol()
	case accountctoken.FieldName:
		return m.Name()
	case accountctoken.FieldEnteredMarket:
		return m.EnteredMarket()
	case accountctoken.FieldCtokenBalance:
		return m.CtokenBalance()
	case accountctoken.FieldStoredBorrowBalance:
		return m.StoredBorrowBalance()
	case accountctoken.FieldBorrowIndex:
		return m.BorrowIndex()
	case accountctoken.FieldTotalUnderlyingSupplied:
		return m.TotalUnderlyingSupplied()
	case accountctoken.FieldTotalUnderlyingRedeemed:
		return m.TotalUnderlyingRedeemed()
	case accountctoken.FieldTotalUnderlyingBorrowed:
		return m.TotalUnderlyingBorrowed()
	case accountctoken.FieldTotalUnderlyingRepaid:
		return m.TotalUnderlyingRepaid()
	case accountctoken.FieldSupplyBalanceUnderlying:
		return m.SupplyBalanceUnderlying()
	case accountctoken.FieldBorrowBalanceUnderlying:
		return m.BorrowBalanceUnderlying()
	case accountctoken.FieldLifetimeSupplyInterestAccrued:
		return m.LifetimeSupplyInterestAccrued()
	case accountctoken.FieldLifetimeBorrowInterestAccrued:
		return m.LifetimeBorrowInterestAccrued()
	case accountctoken.FieldSafeWithdrawAmountUnderlying:
		return m.SafeWithdrawAmountUnderlying()
	case accountctoken.FieldCollateralValueInUsd:
		return m.CollateralValueInUsd()
	case accountctoken.FieldBorrowValueInUsd:
		return m.BorrowValueInUsd()
	case accountctoken.FieldUnderlyingPriceUsd:
		return m.UnderlyingPriceUsd()
	case accountctoken.FieldBlockNumber:
		return m.BlockNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountCTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountctoken.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case accountctoken.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case accountctoken.FieldUser:
		return m.OldUser(ctx)
	case accountctoken.FieldAddress:
		return m.OldAddress(ctx)
	case accountctoken.FieldSymbol:
		return m.OldSymbol(ctx)
	case accountctoken.FieldName:
		return m.OldName(ctx)
	case accountctoken.FieldEnteredMarket:
		return m.OldEnteredMarket(ctx)
	case accountctoken.FieldCtokenBalance:
		return m.OldCtokenBalance(ctx)
	case accountctoken.FieldStoredBorrowBalance:
		return m.OldStoredBorrowBalance(ctx)
	case accountctoken.FieldBorrowIndex:
		return m.OldBorrowIndex(ctx)
	case accountctoken.FieldTotalUnderlyingSupplied:
		return m.OldTotalUnderlyingSupplied(ctx)
	case accountctoken.FieldTotalUnderlyingRedeemed:
		return m.OldTotalUnderlyingRedeemed(ctx)
	case accountctoken.FieldTotalUnderlyingBorrowed:
		return m.OldTotalUnderlyingBorrowed(ctx)
	case accountctoken.FieldTotalUnderlyingRepaid:
		return m.OldTotalUnderlyingRepaid(ctx)
	case accountctoken.FieldSupplyBalanceUnderlying:
		return m.OldSupplyBalanceUnderlying(ctx)
	case accountctoken.FieldBorrowBalanceUnderlying:
		return m.OldBorrowBalanceUnderlying(ctx)
	case accountctoken.FieldLifetimeSupplyInterestAccrued:
		return m.OldLifetimeSupplyInterestAccrued(ctx)
	case accountctoken.FieldLifetimeBorrowInterestAccrued:
		return m.OldLifetimeBorrowInterestAccrued(ctx)
	case accountctoken.FieldSafeWithdrawAmountUnderlying:
		return m.OldSafeWithdrawAmountUnderlying(ctx)
	case accountctoken.FieldCollateralValueInUsd:
		return m.OldCollateralValueInUsd(ctx)
	case accountctoken.FieldBorrowValueInUsd:
		return m.OldBorrowValueInUsd(ctx)
	case accountctoken.FieldUnderlyingPriceUsd:
		return m.OldUnderlyingPriceUsd(ctx)
	case accountctoken.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	}
	return nil, fmt.Errorf("unknown AccountCToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountCTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountctoken.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case accountctoken.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case accountctoken.FieldUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser(v)
		return nil
	case accountctoken.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case accountctoken.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case accountctoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case accountctoken.FieldEnteredMarket:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnteredMarket(v)
		return nil
	case accountctoken.FieldCtokenBalance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCtokenBalance(v)
		return nil
	case accountctoken.FieldStoredBorrowBalance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoredBorrowBalance(v)
		return nil
	case accountctoken.FieldBorrowIndex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBorrowIndex(v)
		return nil
	case accountctoken.FieldTotalUnderlyingSupplied:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUnderlyingSupplied(v)
		return nil
	case accountctoken.FieldTotalUnderlyingRedeemed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUnderlyingRedeemed(v)
		return nil
	case accountctoken.FieldTotalUnderlyingBorrowed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUnderlyingBorrowed(v)
		return nil
	case accountctoken.FieldTotalUnderlyingRepaid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUnderlyingRepaid(v)
		return nil
	case accountctoken.FieldSupplyBalanceUnderlying:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplyBalanceUnderlying(v)
		return nil
	case accountctoken.FieldBorrowBalanceUnderlying:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBorrowBalanceUnderlying(v)
		return nil
	case accountctoken.FieldLifetimeSupplyInterestAccrued:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifetimeSupplyInterestAccrued(v)
		return nil
	case accountctoken.FieldLifetimeBorrowInterestAccrued:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifetimeBorrowInterestAccrued(v)
		return nil
	case accountctoken.FieldSafeWithdrawAmountUnderlying:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSafeWithdrawAmountUnderlying(v)
		return nil
	case accountctoken.FieldCollateralValueInUsd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollateralValueInUsd(v)
		return nil
	case accountctoken.FieldBorrowValueInUsd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBorrowValueInUsd(v)
		return nil
	case accountctoken.FieldUnderlyingPriceUsd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnderlyingPriceUsd(v)
		return nil
	case accountctoken.FieldBlockNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	}
	return fmt.Errorf("unknown AccountCToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountCTokenMutation) AddedFields() []string {
	var fields []string
	if m.addblock_number != nil {
		fields = append(fields, accountctoken.FieldBlockNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountCTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountctoken.FieldBlockNumber:
		return m.AddedBlockNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountCTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountctoken.FieldBlockNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	}
	return fmt.Errorf("unknown AccountCToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountCTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountCTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountCTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountCToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountCTokenMutation) ResetField(name string) error {
	switch name {
	case accountctoken.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case accountctoken.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case accountctoken.FieldUser:
		m.ResetUser()
		return nil
	case accountctoken.FieldAddress:
		m.ResetAddress()
		return nil
	case accountctoken.FieldSymbol:
		m.ResetSymbol()
		return nil
	case accountctoken.FieldName:
		m.ResetName()
		return nil
	case accountctoken.FieldEnteredMarket:
		m.ResetEnteredMarket()
		return nil
	case accountctoken.FieldCtokenBalance:
		m.ResetCtokenBalance()
		return nil
	case accountctoken.FieldStoredBorrowBalance:
		m.ResetStoredBorrowBalance()
		return nil
	case accountctoken.FieldBorrowIndex:
		m.ResetBorrowIndex()
		return nil
	case accountctoken.FieldTotalUnderlyingSupplied:
		m.ResetTotalUnderlyingSupplied()
		return nil
	case accountctoken.FieldTotalUnderlyingRedeemed:
		m.ResetTotalUnderlyingRedeemed()
		return nil
	case accountctoken.FieldTotalUnderlyingBorrowed:
		m.ResetTotalUnderlyingBorrowed()
		return nil
	case accountctoken.FieldTotalUnderlyingRepaid:
		m.ResetTotalUnderlyingRepaid()
		return nil
	case accountctoken.FieldSupplyBalanceUnderlying:
		m.ResetSupplyBalanceUnderlying()
		return nil
	case accountctoken.FieldBorrowBalanceUnderlying:
		m.ResetBorrowBalanceUnderlying()
		return nil
	case accountctoken.FieldLifetimeSupplyInterestAccrued:
		m.ResetLifetimeSupplyInterestAccrued()
		return nil
	case accountctoken.FieldLifetimeBorrowInterestAccrued:
		m.ResetLifetimeBorrowInterestAccrued()
		return nil
	case accountctoken.FieldSafeWithdrawAmountUnderlying:
		m.ResetSafeWithdrawAmountUnderlying()
		return nil
	case accountctoken.FieldCollateralValueInUsd:
		m.ResetCollateralValueInUsd()
		return nil
	case accountctoken.FieldBorrowValueInUsd:
		m.ResetBorrowValueInUsd()
		return nil
	case accountctoken.FieldUnderlyingPriceUsd:
		m.ResetUnderlyingPriceUsd()
		return nil
	case accountctoken.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	}
	return fmt.Errorf("unknown AccountCToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountCTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, accountctoken.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountCTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountctoken.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountCTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountCTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountCTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, accountctoken.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountCTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case accountctoken.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountCTokenMutation) ClearEdge(name string) error {
	switch name {
	case accountctoken.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountCToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountCTokenMutation) ResetEdge(name string) error {
	switch name {
	case accountctoken.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountCToken edge %s", name)
}

// MarketMutation represents an operation that mutates the Market nodes in the graph.
type MarketMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	address                *string
	symbol                 *string
	name                   *string
	borrow_index           *string
	borrow_rate            *string
	supply_rate            *string
	cash                   *string
	collateral_factor      *string
	exchange_rate          *string
	reserve_factor         *string
	reserves               *string
	total_borrows          *string
	total_supply           *string
	underlying_address     *string
	underlying_name        *string
	underlying_symbol      *string
	underlying_price       *string
	underlying_decimals    *uint32
	addunderlying_decimals *int32
	underlying_price_usd   *string
	block_number           *uint64
	addblock_number        *int64
	block_timestamp        *uint32
	addblock_timestamp     *int32
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*Market, error)
	predicates             []predicate.Market
}

var _ ent.Mutation = (*MarketMutation)(nil)

// marketOption allows management of the mutation configuration using functional options.
type marketOption func(*MarketMutation)

// newMarketMutation creates new mutation for the Market entity.
func newMarketMutation(c config, op Op, opts ...marketOption) *MarketMutation {
	m := &MarketMutation{
		config:        c,
		op:            op,
		typ:           TypeMarket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMarketID sets the ID field of the mutation.
func withMarketID(id int) marketOption {
	return func(m *MarketMutation) {
		var (
			err   error
			once  sync.Once
			value *Market
		)
		m.oldValue = func(ctx context.Context) (*Market, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Market.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMarket sets the old Market of the mutation.
func withMarket(node *Market) marketOption {
	return func(m *MarketMutation) {
		m.oldValue = func(context.Context) (*Market, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MarketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MarketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MarketMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MarketMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Market.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MarketMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MarketMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MarketMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MarketMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MarketMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MarketMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAddress sets the "address" field.
func (m *MarketMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *MarketMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *MarketMutation) ResetAddress() {
	m.address = nil
}

// SetSymbol sets the "symbol" field.
func (m *MarketMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *MarketMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *MarketMutation) ResetSymbol() {
	m.symbol = nil
}

// SetName sets the "name" field.
func (m *MarketMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MarketMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MarketMutation) ResetName() {
	m.name = nil
}

// SetBorrowIndex sets the "borrow_index" field.
func (m *MarketMutation) SetBorrowIndex(s string) {
	m.borrow_index = &s
}

// BorrowIndex returns the value of the "borrow_index" field in the mutation.
func (m *MarketMutation) BorrowIndex() (r string, exists bool) {
	v := m.borrow_index
	if v == nil {
		return
	}
	return *v, true
}

// OldBorrowIndex returns the old "borrow_index" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldBorrowIndex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBorrowIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBorrowIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBorrowIndex: %w", err)
	}
	return oldValue.BorrowIndex, nil
}

// ResetBorrowIndex resets all changes to the "borrow_index" field.
func (m *MarketMutation) ResetBorrowIndex() {
	m.borrow_index = nil
}

// SetBorrowRate sets the "borrow_rate" field.
func (m *MarketMutation) SetBorrowRate(s string) {
	m.borrow_rate = &s
}

// BorrowRate returns the value of the "borrow_rate" field in the mutation.
func (m *MarketMutation) BorrowRate() (r string, exists bool) {
	v := m.borrow_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldBorrowRate returns the old "borrow_rate" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldBorrowRate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBorrowRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBorrowRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBorrowRate: %w", err)
	}
	return oldValue.BorrowRate, nil
}

// ResetBorrowRate resets all changes to the "borrow_rate" field.
func (m *MarketMutation) ResetBorrowRate() {
	m.borrow_rate = nil
}

// SetSupplyRate sets the "supply_rate" field.
func (m *MarketMutation) SetSupplyRate(s string) {
	m.supply_rate = &s
}

// SupplyRate returns the value of the "supply_rate" field in the mutation.
func (m *MarketMutation) SupplyRate() (r string, exists bool) {
	v := m.supply_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplyRate returns the old "supply_rate" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldSupplyRate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplyRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplyRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplyRate: %w", err)
	}
	return oldValue.SupplyRate, nil
}

// ResetSupplyRate resets all changes to the "supply_rate" field.
func (m *MarketMutation) ResetSupplyRate() {
	m.supply_rate = nil
}

// SetCash sets the "cash" field.
func (m *MarketMutation) SetCash(s string) {
	m.cash = &s
}

// Cash returns the value of the "cash" field in the mutation.
func (m *MarketMutation) Cash() (r string, exists bool) {
	v := m.cash
	if v == nil {
		return
	}
	return *v, true
}

// OldCash returns the old "cash" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldCash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCash: %w", err)
	}
	return oldValue.Cash, nil
}

// ResetCash resets all changes to the "cash" field.
func (m *MarketMutation) ResetCash() {
	m.cash = nil
}

// SetCollateralFactor sets the "collateral_factor" field.
func (m *MarketMutation) SetCollateralFactor(s string) {
	m.collateral_factor = &s
}

// CollateralFactor returns the value of the "collateral_factor" field in the mutation.
func (m *MarketMutation) CollateralFactor() (r string, exists bool) {
	v := m.collateral_factor
	if v == nil {
		return
	}
	return *v, true
}

// OldCollateralFactor returns the old "collateral_factor" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldCollateralFactor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollateralFactor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollateralFactor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollateralFactor: %w", err)
	}
	return oldValue.CollateralFactor, nil
}

// ResetCollateralFactor resets all changes to the "collateral_factor" field.
func (m *MarketMutation) ResetCollateralFactor() {
	m.collateral_factor = nil
}

// SetExchangeRate sets the "exchange_rate" field.
func (m *MarketMutation) SetExchangeRate(s string) {
	m.exchange_rate = &s
}

// ExchangeRate returns the value of the "exchange_rate" field in the mutation.
func (m *MarketMutation) ExchangeRate() (r string, exists bool) {
	v := m.exchange_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeRate returns the old "exchange_rate" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldExchangeRate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeRate: %w", err)
	}
	return oldValue.ExchangeRate, nil
}

// ResetExchangeRate resets all changes to the "exchange_rate" field.
func (m *MarketMutation) ResetExchangeRate() {
	m.exchange_rate = nil
}

// SetReserveFactor sets the "reserve_factor" field.
func (m *MarketMutation) SetReserveFactor(s string) {
	m.reserve_factor = &s
}

// ReserveFactor returns the value of the "reserve_factor" field in the mutation.
func (m *MarketMutation) ReserveFactor() (r string, exists bool) {
	v := m.reserve_factor
	if v == nil {
		return
	}
	return *v, true
}

// OldReserveFactor returns the old "reserve_factor" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldReserveFactor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReserveFactor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReserveFactor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserveFactor: %w", err)
	}
	return oldValue.ReserveFactor, nil
}

// ResetReserveFactor resets all changes to the "reserve_factor" field.
func (m *MarketMutation) ResetReserveFactor() {
	m.reserve_factor = nil
}

// SetReserves sets the "reserves" field.
func (m *MarketMutation) SetReserves(s string) {
	m.reserves = &s
}

// Reserves returns the value of the "reserves" field in the mutation.
func (m *MarketMutation) Reserves() (r string, exists bool) {
	v := m.reserves
	if v == nil {
		return
	}
	return *v, true
}

// OldReserves returns the old "reserves" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldReserves(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReserves is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReserves requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserves: %w", err)
	}
	return oldValue.Reserves, nil
}

// ResetReserves resets all changes to the "reserves" field.
func (m *MarketMutation) ResetReserves() {
	m.reserves = nil
}

// SetTotalBorrows sets the "total_borrows" field.
func (m *MarketMutation) SetTotalBorrows(s string) {
	m.total_borrows = &s
}

// TotalBorrows returns the value of the "total_borrows" field in the mutation.
func (m *MarketMutation) TotalBorrows() (r string, exists bool) {
	v := m.total_borrows
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalBorrows returns the old "total_borrows" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldTotalBorrows(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalBorrows is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalBorrows requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalBorrows: %w", err)
	}
	return oldValue.TotalBorrows, nil
}

// ResetTotalBorrows resets all changes to the "total_borrows" field.
func (m *MarketMutation) ResetTotalBorrows() {
	m.total_borrows = nil
}

// SetTotalSupply sets the "total_supply" field.
func (m *MarketMutation) SetTotalSupply(s string) {
	m.total_supply = &s
}

// TotalSupply returns the value of the "total_supply" field in the mutation.
func (m *MarketMutation) TotalSupply() (r string, exists bool) {
	v := m.total_supply
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSupply returns the old "total_supply" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldTotalSupply(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSupply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSupply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSupply: %w", err)
	}
	return oldValue.TotalSupply, nil
}

// ResetTotalSupply resets all changes to the "total_supply" field.
func (m *MarketMutation) ResetTotalSupply() {
	m.total_supply = nil
}

// SetUnderlyingAddress sets the "underlying_address" field.
func (m *MarketMutation) SetUnderlyingAddress(s string) {
	m.underlying_address = &s
}

// UnderlyingAddress returns the value of the "underlying_address" field in the mutation.
func (m *MarketMutation) UnderlyingAddress() (r string, exists bool) {
	v := m.underlying_address
	if v == nil {
		return
	}
	return *v, true
}

// OldUnderlyingAddress returns the old "underlying_address" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldUnderlyingAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnderlyingAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnderlyingAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnderlyingAddress: %w", err)
	}
	return oldValue.UnderlyingAddress, nil
}

// ResetUnderlyingAddress resets all changes to the "underlying_address" field.
func (m *MarketMutation) ResetUnderlyingAddress() {
	m.underlying_address = nil
}

// SetUnderlyingName sets the "underlying_name" field.
func (m *MarketMutation) SetUnderlyingName(s string) {
	m.underlying_name = &s
}

// UnderlyingName returns the value of the "underlying_name" field in the mutation.
func (m *MarketMutation) UnderlyingName() (r string, exists bool) {
	v := m.underlying_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUnderlyingName returns the old "underlying_name" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldUnderlyingName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnderlyingName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnderlyingName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnderlyingName: %w", err)
	}
	return oldValue.UnderlyingName, nil
}

// ResetUnderlyingName resets all changes to the "underlying_name" field.
func (m *MarketMutation) ResetUnderlyingName() {
	m.underlying_name = nil
}

// SetUnderlyingSymbol sets the "underlying_symbol" field.
func (m *MarketMutation) SetUnderlyingSymbol(s string) {
	m.underlying_symbol = &s
}

// UnderlyingSymbol returns the value of the "underlying_symbol" field in the mutation.
func (m *MarketMutation) UnderlyingSymbol() (r string, exists bool) {
	v := m.underlying_symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldUnderlyingSymbol returns the old "underlying_symbol" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldUnderlyingSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnderlyingSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnderlyingSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnderlyingSymbol: %w", err)
	}
	return oldValue.UnderlyingSymbol, nil
}

// ResetUnderlyingSymbol resets all changes to the "underlying_symbol" field.
func (m *MarketMutation) ResetUnderlyingSymbol() {
	m.underlying_symbol = nil
}

// SetUnderlyingPrice sets the "underlying_price" field.
func (m *MarketMutation) SetUnderlyingPrice(s string) {
	m.underlying_price = &s
}

// UnderlyingPrice returns the value of the "underlying_price" field in the mutation.
func (m *MarketMutation) UnderlyingPrice() (r string, exists bool) {
	v := m.underlying_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnderlyingPrice returns the old "underlying_price" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldUnderlyingPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnderlyingPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnderlyingPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnderlyingPrice: %w", err)
	}
	return oldValue.UnderlyingPrice, nil
}

// ResetUnderlyingPrice resets all changes to the "underlying_price" field.
func (m *MarketMutation) ResetUnderlyingPrice() {
	m.underlying_price = nil
}

// SetUnderlyingDecimals sets the "underlying_decimals" field.
func (m *MarketMutation) SetUnderlyingDecimals(u uint32) {
	m.underlying_decimals = &u
	m.addunderlying_decimals = nil
}

// UnderlyingDecimals returns the value of the "underlying_decimals" field in the mutation.
func (m *MarketMutation) UnderlyingDecimals() (r uint32, exists bool) {
	v := m.underlying_decimals
	if v == nil {
		return
	}
	return *v, true
}

// OldUnderlyingDecimals returns the old "underlying_decimals" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldUnderlyingDecimals(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnderlyingDecimals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnderlyingDecimals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnderlyingDecimals: %w", err)
	}
	return oldValue.UnderlyingDecimals, nil
}

// AddUnderlyingDecimals adds u to the "underlying_decimals" field.
func (m *MarketMutation) AddUnderlyingDecimals(u int32) {
	if m.addunderlying_decimals != nil {
		*m.addunderlying_decimals += u
	} else {
		m.addunderlying_decimals = &u
	}
}

// AddedUnderlyingDecimals returns the value that was added to the "underlying_decimals" field in this mutation.
func (m *MarketMutation) AddedUnderlyingDecimals() (r int32, exists bool) {
	v := m.addunderlying_decimals
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnderlyingDecimals resets all changes to the "underlying_decimals" field.
func (m *MarketMutation) ResetUnderlyingDecimals() {
	m.underlying_decimals = nil
	m.addunderlying_decimals = nil
}

// SetUnderlyingPriceUsd sets the "underlying_price_usd" field.
func (m *MarketMutation) SetUnderlyingPriceUsd(s string) {
	m.underlying_price_usd = &s
}

// UnderlyingPriceUsd returns the value of the "underlying_price_usd" field in the mutation.
func (m *MarketMutation) UnderlyingPriceUsd() (r string, exists bool) {
	v := m.underlying_price_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldUnderlyingPriceUsd returns the old "underlying_price_usd" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldUnderlyingPriceUsd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnderlyingPriceUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnderlyingPriceUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnderlyingPriceUsd: %w", err)
	}
	return oldValue.UnderlyingPriceUsd, nil
}

// ResetUnderlyingPriceUsd resets all changes to the "underlying_price_usd" field.
func (m *MarketMutation) ResetUnderlyingPriceUsd() {
	m.underlying_price_usd = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *MarketMutation) SetBlockNumber(u uint64) {
	m.block_number = &u
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *MarketMutation) BlockNumber() (r uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldBlockNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds u to the "block_number" field.
func (m *MarketMutation) AddBlockNumber(u int64) {
	if m.addblock_number != nil {
		*m.addblock_number += u
	} else {
		m.addblock_number = &u
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *MarketMutation) AddedBlockNumber() (r int64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *MarketMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// SetBlockTimestamp sets the "block_timestamp" field.
func (m *MarketMutation) SetBlockTimestamp(u uint32) {
	m.block_timestamp = &u
	m.addblock_timestamp = nil
}

// BlockTimestamp returns the value of the "block_timestamp" field in the mutation.
func (m *MarketMutation) BlockTimestamp() (r uint32, exists bool) {
	v := m.block_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockTimestamp returns the old "block_timestamp" field's value of the Market entity.
// If the Market object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketMutation) OldBlockTimestamp(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockTimestamp: %w", err)
	}
	return oldValue.BlockTimestamp, nil
}

// AddBlockTimestamp adds u to the "block_timestamp" field.
func (m *MarketMutation) AddBlockTimestamp(u int32) {
	if m.addblock_timestamp != nil {
		*m.addblock_timestamp += u
	} else {
		m.addblock_timestamp = &u
	}
}

// AddedBlockTimestamp returns the value that was added to the "block_timestamp" field in this mutation.
func (m *MarketMutation) AddedBlockTimestamp() (r int32, exists bool) {
	v := m.addblock_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockTimestamp resets all changes to the "block_timestamp" field.
func (m *MarketMutation) ResetBlockTimestamp() {
	m.block_timestamp = nil
	m.addblock_timestamp = nil
}

// Where appends a list predicates to the MarketMutation builder.
func (m *MarketMutation) Where(ps ...predicate.Market) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MarketMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Market).
func (m *MarketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MarketMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.create_time != nil {
		fields = append(fields, market.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, market.FieldUpdateTime)
	}
	if m.address != nil {
		fields = append(fields, market.FieldAddress)
	}
	if m.symbol != nil {
		fields = append(fields, market.FieldSymbol)
	}
	if m.name != nil {
		fields = append(fields, market.FieldName)
	}
	if m.borrow_index != nil {
		fields = append(fields, market.FieldBorrowIndex)
	}
	if m.borrow_rate != nil {
		fields = append(fields, market.FieldBorrowRate)
	}
	if m.supply_rate != nil {
		fields = append(fields, market.FieldSupplyRate)
	}
	if m.cash != nil {
		fields = append(fields, market.FieldCash)
	}
	if m.collateral_factor != nil {
		fields = append(fields, market.FieldCollateralFactor)
	}
	if m.exchange_rate != nil {
		fields = append(fields, market.FieldExchangeRate)
	}
	if m.reserve_factor != nil {
		fields = append(fields, market.FieldReserveFactor)
	}
	if m.reserves != nil {
		fields = append(fields, market.FieldReserves)
	}
	if m.total_borrows != nil {
		fields = append(fields, market.FieldTotalBorrows)
	}
	if m.total_supply != nil {
		fields = append(fields, market.FieldTotalSupply)
	}
	if m.underlying_address != nil {
		fields = append(fields, market.FieldUnderlyingAddress)
	}
	if m.underlying_name != nil {
		fields = append(fields, market.FieldUnderlyingName)
	}
	if m.underlying_symbol != nil {
		fields = append(fields, market.FieldUnderlyingSymbol)
	}
	if m.underlying_price != nil {
		fields = append(fields, market.FieldUnderlyingPrice)
	}
	if m.underlying_decimals != nil {
		fields = append(fields, market.FieldUnderlyingDecimals)
	}
	if m.underlying_price_usd != nil {
		fields = append(fields, market.FieldUnderlyingPriceUsd)
	}
	if m.block_number != nil {
		fields = append(fields, market.FieldBlockNumber)
	}
	if m.block_timestamp != nil {
		fields = append(fields, market.FieldBlockTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MarketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case market.FieldCreateTime:
		return m.CreateTime()
	case market.FieldUpdateTime:
		return m.UpdateTime()
	case market.FieldAddress:
		return m.Address()
	case market.FieldSymbol:
		return m.Symbol()
	case market.FieldName:
		return m.Name()
	case market.FieldBorrowIndex:
		return m.BorrowIndex()
	case market.FieldBorrowRate:
		return m.BorrowRate()
	case market.FieldSupplyRate:
		return m.SupplyRate()
	case market.FieldCash:
		return m.Cash()
	case market.FieldCollateralFactor:
		return m.CollateralFactor()
	case market.FieldExchangeRate:
		return m.ExchangeRate()
	case market.FieldReserveFactor:
		return m.ReserveFactor()
	case market.FieldReserves:
		return m.Reserves()
	case market.FieldTotalBorrows:
		return m.TotalBorrows()
	case market.FieldTotalSupply:
		return m.TotalSupply()
	case market.FieldUnderlyingAddress:
		return m.UnderlyingAddress()
	case market.FieldUnderlyingName:
		return m.UnderlyingName()
	case market.FieldUnderlyingSymbol:
		return m.UnderlyingSymbol()
	case market.FieldUnderlyingPrice:
		return m.UnderlyingPrice()
	case market.FieldUnderlyingDecimals:
		return m.UnderlyingDecimals()
	case market.FieldUnderlyingPriceUsd:
		return m.UnderlyingPriceUsd()
	case market.FieldBlockNumber:
		return m.BlockNumber()
	case market.FieldBlockTimestamp:
		return m.BlockTimestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MarketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case market.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case market.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case market.FieldAddress:
		return m.OldAddress(ctx)
	case market.FieldSymbol:
		return m.OldSymbol(ctx)
	case market.FieldName:
		return m.OldName(ctx)
	case market.FieldBorrowIndex:
		return m.OldBorrowIndex(ctx)
	case market.FieldBorrowRate:
		return m.OldBorrowRate(ctx)
	case market.FieldSupplyRate:
		return m.OldSupplyRate(ctx)
	case market.FieldCash:
		return m.OldCash(ctx)
	case market.FieldCollateralFactor:
		return m.OldCollateralFactor(ctx)
	case market.FieldExchangeRate:
		return m.OldExchangeRate(ctx)
	case market.FieldReserveFactor:
		return m.OldReserveFactor(ctx)
	case market.FieldReserves:
		return m.OldReserves(ctx)
	case market.FieldTotalBorrows:
		return m.OldTotalBorrows(ctx)
	case market.FieldTotalSupply:
		return m.OldTotalSupply(ctx)
	case market.FieldUnderlyingAddress:
		return m.OldUnderlyingAddress(ctx)
	case market.FieldUnderlyingName:
		return m.OldUnderlyingName(ctx)
	case market.FieldUnderlyingSymbol:
		return m.OldUnderlyingSymbol(ctx)
	case market.FieldUnderlyingPrice:
		return m.OldUnderlyingPrice(ctx)
	case market.FieldUnderlyingDecimals:
		return m.OldUnderlyingDecimals(ctx)
	case market.FieldUnderlyingPriceUsd:
		return m.OldUnderlyingPriceUsd(ctx)
	case market.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case market.FieldBlockTimestamp:
		return m.OldBlockTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Market field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MarketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case market.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case market.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case market.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case market.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case market.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case market.FieldBorrowIndex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBorrowIndex(v)
		return nil
	case market.FieldBorrowRate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBorrowRate(v)
		return nil
	case market.FieldSupplyRate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplyRate(v)
		return nil
	case market.FieldCash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCash(v)
		return nil
	case market.FieldCollateralFactor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollateralFactor(v)
		return nil
	case market.FieldExchangeRate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeRate(v)
		return nil
	case market.FieldReserveFactor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserveFactor(v)
		return nil
	case market.FieldReserves:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserves(v)
		return nil
	case market.FieldTotalBorrows:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalBorrows(v)
		return nil
	case market.FieldTotalSupply:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSupply(v)
		return nil
	case market.FieldUnderlyingAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnderlyingAddress(v)
		return nil
	case market.FieldUnderlyingName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnderlyingName(v)
		return nil
	case market.FieldUnderlyingSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnderlyingSymbol(v)
		return nil
	case market.FieldUnderlyingPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnderlyingPrice(v)
		return nil
	case market.FieldUnderlyingDecimals:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnderlyingDecimals(v)
		return nil
	case market.FieldUnderlyingPriceUsd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnderlyingPriceUsd(v)
		return nil
	case market.FieldBlockNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case market.FieldBlockTimestamp:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Market field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MarketMutation) AddedFields() []string {
	var fields []string
	if m.addunderlying_decimals != nil {
		fields = append(fields, market.FieldUnderlyingDecimals)
	}
	if m.addblock_number != nil {
		fields = append(fields, market.FieldBlockNumber)
	}
	if m.addblock_timestamp != nil {
		fields = append(fields, market.FieldBlockTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MarketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case market.FieldUnderlyingDecimals:
		return m.AddedUnderlyingDecimals()
	case market.FieldBlockNumber:
		return m.AddedBlockNumber()
	case market.FieldBlockTimestamp:
		return m.AddedBlockTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MarketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case market.FieldUnderlyingDecimals:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnderlyingDecimals(v)
		return nil
	case market.FieldBlockNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	case market.FieldBlockTimestamp:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Market numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MarketMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MarketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MarketMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Market nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MarketMutation) ResetField(name string) error {
	switch name {
	case market.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case market.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case market.FieldAddress:
		m.ResetAddress()
		return nil
	case market.FieldSymbol:
		m.ResetSymbol()
		return nil
	case market.FieldName:
		m.ResetName()
		return nil
	case market.FieldBorrowIndex:
		m.ResetBorrowIndex()
		return nil
	case market.FieldBorrowRate:
		m.ResetBorrowRate()
		return nil
	case market.FieldSupplyRate:
		m.ResetSupplyRate()
		return nil
	case market.FieldCash:
		m.ResetCash()
		return nil
	case market.FieldCollateralFactor:
		m.ResetCollateralFactor()
		return nil
	case market.FieldExchangeRate:
		m.ResetExchangeRate()
		return nil
	case market.FieldReserveFactor:
		m.ResetReserveFactor()
		return nil
	case market.FieldReserves:
		m.ResetReserves()
		return nil
	case market.FieldTotalBorrows:
		m.ResetTotalBorrows()
		return nil
	case market.FieldTotalSupply:
		m.ResetTotalSupply()
		return nil
	case market.FieldUnderlyingAddress:
		m.ResetUnderlyingAddress()
		return nil
	case market.FieldUnderlyingName:
		m.ResetUnderlyingName()
		return nil
	case market.FieldUnderlyingSymbol:
		m.ResetUnderlyingSymbol()
		return nil
	case market.FieldUnderlyingPrice:
		m.ResetUnderlyingPrice()
		return nil
	case market.FieldUnderlyingDecimals:
		m.ResetUnderlyingDecimals()
		return nil
	case market.FieldUnderlyingPriceUsd:
		m.ResetUnderlyingPriceUsd()
		return nil
	case market.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case market.FieldBlockTimestamp:
		m.ResetBlockTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Market field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MarketMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MarketMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MarketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MarketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MarketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MarketMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MarketMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Market unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MarketMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Market edge %s", name)
}

// PreferenceMutation represents an operation that mutates the Preference nodes in the graph.
type PreferenceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	key           *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Preference, error)
	predicates    []predicate.Preference
}

var _ ent.Mutation = (*PreferenceMutation)(nil)

// preferenceOption allows management of the mutation configuration using functional options.
type preferenceOption func(*PreferenceMutation)

// newPreferenceMutation creates new mutation for the Preference entity.
func newPreferenceMutation(c config, op Op, opts ...preferenceOption) *PreferenceMutation {
	m := &PreferenceMutation{
		config:        c,
		op:            op,
		typ:           TypePreference,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPreferenceID sets the ID field of the mutation.
func withPreferenceID(id int) preferenceOption {
	return func(m *PreferenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Preference
		)
		m.oldValue = func(ctx context.Context) (*Preference, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Preference.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPreference sets the old Preference of the mutation.
func withPreference(node *Preference) preferenceOption {
	return func(m *PreferenceMutation) {
		m.oldValue = func(context.Context) (*Preference, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PreferenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PreferenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PreferenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PreferenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Preference.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PreferenceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PreferenceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Preference entity.
// If the Preference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreferenceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PreferenceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PreferenceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PreferenceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Preference entity.
// If the Preference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreferenceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PreferenceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetKey sets the "key" field.
func (m *PreferenceMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PreferenceMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Preference entity.
// If the Preference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreferenceMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PreferenceMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *PreferenceMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *PreferenceMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Preference entity.
// If the Preference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreferenceMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PreferenceMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the PreferenceMutation builder.
func (m *PreferenceMutation) Where(ps ...predicate.Preference) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PreferenceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Preference).
func (m *PreferenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PreferenceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, preference.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, preference.FieldUpdateTime)
	}
	if m.key != nil {
		fields = append(fields, preference.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, preference.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PreferenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case preference.FieldCreateTime:
		return m.CreateTime()
	case preference.FieldUpdateTime:
		return m.UpdateTime()
	case preference.FieldKey:
		return m.Key()
	case preference.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PreferenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case preference.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case preference.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case preference.FieldKey:
		return m.OldKey(ctx)
	case preference.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Preference field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreferenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case preference.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case preference.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case preference.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case preference.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Preference field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PreferenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PreferenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreferenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Preference numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PreferenceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PreferenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PreferenceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Preference nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PreferenceMutation) ResetField(name string) error {
	switch name {
	case preference.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case preference.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case preference.FieldKey:
		m.ResetKey()
		return nil
	case preference.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Preference field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PreferenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PreferenceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PreferenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PreferenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PreferenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PreferenceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PreferenceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Preference unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PreferenceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Preference edge %s", name)
}
